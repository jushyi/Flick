---
phase: 01-message-infrastructure-read-receipts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - firestore.rules
  - src/services/firebase/messageService.js
  - src/hooks/useConversation.js
  - functions/index.js
  - __tests__/services/messageService.test.js
  - __tests__/hooks/useConversation.test.js
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - READ-02
  - READ-03

must_haves:
  truths:
    - 'markConversationRead writes readReceipts.[userId] timestamp alongside unreadCount reset in a single Firestore write'
    - 'markConversationRead only writes readReceipts when there are unread messages (first-read-only semantics)'
    - 'Firestore rules allow conversation participants to update readReceipts field'
    - 'Firestore rules allow message recipients (not senders) to update viewedAt and screenshotted fields'
    - 'useConversation hook subscribes to conversation document and exposes readReceipts data'
    - 'onNewMessage Cloud Function handles type field for lastMessage preview text generation'
  artifacts:
    - path: 'firestore.rules'
      provides: 'Updated conversation and message update rules'
      contains: 'readReceipts'
    - path: 'src/services/firebase/messageService.js'
      provides: 'Extended markConversationRead with readReceipts'
      contains: 'readReceipts'
    - path: 'src/hooks/useConversation.js'
      provides: 'Conversation document subscription with readReceipts'
      contains: 'readReceipts'
    - path: 'functions/index.js'
      provides: 'Extended onNewMessage for message type preview text'
      contains: 'lastMessage'
    - path: '__tests__/services/messageService.test.js'
      provides: 'Tests for readReceipts in markConversationRead'
      contains: 'readReceipts'
    - path: '__tests__/hooks/useConversation.test.js'
      provides: 'Tests for conversation doc subscription and read state'
      contains: 'readReceipts'
  key_links:
    - from: 'src/services/firebase/messageService.js'
      to: 'firestore.rules'
      via: 'Firestore updateDoc with readReceipts field'
      pattern: 'readReceipts.*serverTimestamp'
    - from: 'src/hooks/useConversation.js'
      to: 'src/services/firebase/messageService.js'
      via: 'Calls markConversationRead when unread messages exist'
      pattern: 'markConversationRead'
    - from: 'src/hooks/useConversation.js'
      to: 'Firestore conversation document'
      via: 'onSnapshot subscription exposes readReceipts'
      pattern: 'onSnapshot.*readReceipts'
---

<objective>
Extend the backend infrastructure for read receipts: update Firestore security rules to allow readReceipts and snap field updates, extend markConversationRead to write readReceipts timestamps, add conversation document subscription to useConversation hook, and extend the onNewMessage Cloud Function for message type previews. Write tests for all service and hook changes.

Purpose: Every subsequent UI task depends on these backend data flows being in place. Firestore rules must allow the writes before any client code can use them. The conversation document subscription provides the real-time data channel that the UI will consume.

Output: Updated firestore.rules, extended messageService.js, extended useConversation.js, extended Cloud Function, and comprehensive tests.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-message-infrastructure-read-receipts/01-CONTEXT.md
@.planning/phases/01-message-infrastructure-read-receipts/01-RESEARCH.md
@firestore.rules
@src/services/firebase/messageService.js
@src/hooks/useConversation.js
@functions/index.js
@__tests__/setup/jest.setup.js
@__tests__/setup/testFactories.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Firestore rules and extend messageService with readReceipts</name>
  <files>
    firestore.rules
    src/services/firebase/messageService.js
  </files>
  <action>
**Firestore Rules (INFRA-01 + INFRA-02):**

1. Open `firestore.rules`. Find the conversation document update rule that currently restricts updates to `hasOnly(['deletedAt', 'unreadCount'])`.
2. Extend the allowed fields list to: `hasOnly(['deletedAt', 'unreadCount', 'readReceipts'])`. This allows participants to write the `readReceipts` field (INFRA-02).
3. Find the messages subcollection rules under `match /conversations/{conversationId}/messages/{messageId}`. Add or update the `allow update` rule so that:
   - Only conversation participants who are NOT the message sender can update
   - Only `viewedAt` and `screenshotted` fields are allowed: `request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewedAt', 'screenshotted'])`
   - This enables INFRA-01 (snap viewedAt updates by recipient)
4. Ensure the `allow create` rule for messages requires `senderId`, `type`, and `createdAt` fields: `request.resource.data.keys().hasAll(['senderId', 'type', 'createdAt'])`. This enforces the type discriminator field on all new messages going forward.
   - NOTE: If this breaks existing message creation (current sendMessage already sets these fields per research), keep it. If the existing create rule does not enforce `type`, add it.

**messageService.js (READ-02):**

5. Open `src/services/firebase/messageService.js`. Find the existing `markConversationRead` function.
6. Extend it to atomically write BOTH `unreadCount.[userId]: 0` AND `readReceipts.[userId]: serverTimestamp()` in a single `updateDoc` call. This is the conversation-level read receipt approach (not per-message).
7. Ensure `serverTimestamp` is imported from `@react-native-firebase/firestore`.
8. The function signature stays the same: `markConversationRead(conversationId, userId)`.
9. The function still returns `{ success: true }` or `{ success: false, error }`.
10. Use the logger for error logging: `logger.error('messageService.markConversationRead: Failed', { conversationId, userId, error: error.message })`.

**Important:** Do NOT add any client-side check for "should we skip the write" inside the service function itself. That guard lives in the hook (Task 2). The service function always writes when called.
</action>
<verify>
<automated>npx jest **tests**/services/messageService.test.js --no-coverage 2>&1 | tail -5</automated>
<manual>Review firestore.rules diff to confirm readReceipts is in the allowed fields list and message update rule restricts to viewedAt/screenshotted for non-senders only</manual>
</verify>
<done> - firestore.rules allows conversation participants to update `readReceipts` field - firestore.rules allows message recipients (not senders) to update `viewedAt` and `screenshotted` - firestore.rules message create rule requires `senderId`, `type`, `createdAt` - markConversationRead writes both `unreadCount.[userId]: 0` and `readReceipts.[userId]: serverTimestamp()` in one updateDoc call - Existing messageService tests still pass
</done>
</task>

<task type="auto">
  <name>Task 2: Extend useConversation hook with conversation document subscription and update Cloud Function</name>
  <files>
    src/hooks/useConversation.js
    functions/index.js
  </files>
  <action>
**useConversation.js (READ-03):**

1. Open `src/hooks/useConversation.js`. The hook currently subscribes to messages but does NOT subscribe to the conversation document itself.
2. Add a new `onSnapshot` subscription to the conversation document (`doc(db, 'conversations', conversationId)`) inside a `useEffect`. This provides real-time `readReceipts` updates.
3. Store the conversation document data in a new state variable: `const [conversationDoc, setConversationDoc] = useState(null)`.
4. From the conversation document, derive and expose:
   - `conversationDoc` (the full document data including `readReceipts`, `unreadCount`, etc.)
5. **First-read-only guard:** Modify the existing `markConversationRead` call (the useEffect that runs on mount/focus) to ONLY call `markConversationRead` when the user has unread messages. Check: `conversationDoc?.unreadCount?.[currentUserId] > 0`. If unreadCount is 0 or missing, skip the write. This preserves the original read timestamp on re-opens (per CONTEXT.md decision: "first-read timestamp only").
6. Return `conversationDoc` from the hook alongside existing return values (messages, sendMessage, loadMore, etc.). Do NOT break existing consumers -- add it as a new field in the return object.
7. Clean up the conversation document subscription in the useEffect cleanup function (call the unsubscribe function returned by `onSnapshot`).
8. Import `doc` and `onSnapshot` from `@react-native-firebase/firestore` if not already imported.

**Cloud Function - onNewMessage (INFRA-01 preparation + preview text):**

9. Open `functions/index.js`. Find the `onNewMessage` function (documented at lines ~2618-2738 per research).
10. Extend the `lastMessage` object that gets written to the conversation document to include the `type` field from the message data. Currently it may only write `text`, `senderId`, `timestamp`. Ensure `type` is included: `type: messageData.type || 'text'`.
11. This prepares for future message types (reactions, replies, snaps, tagged photos) whose `lastMessage` preview text will be generated by the client side (ConversationRow) based on the `type` field.
12. If the function already writes `type` to `lastMessage`, verify and leave as-is.
13. Use the existing logger pattern in the Cloud Function for any new log statements.
    </action>
    <verify>
    <automated>npx jest **tests**/hooks/useConversation.test.js --no-coverage 2>&1 | tail -5</automated>
    <manual>Review useConversation.js to confirm conversation document onSnapshot subscription exists with cleanup, and that markConversationRead is gated by unreadCount > 0</manual>
    </verify>
    <done> - useConversation hook subscribes to conversation document via onSnapshot - conversationDoc (including readReceipts) is returned from the hook - markConversationRead is only called when unreadCount > 0 (first-read-only semantics) - Subscription is properly cleaned up on unmount - onNewMessage Cloud Function includes `type` field in lastMessage object
    </done>
    </task>

<task type="auto">
  <name>Task 3: Write tests for messageService readReceipts and useConversation subscription</name>
  <files>
    __tests__/services/messageService.test.js
    __tests__/hooks/useConversation.test.js
  </files>
  <action>
**messageService tests:**

1. Open `__tests__/services/messageService.test.js`. This file already exists with tests for existing messageService functions.
2. Add a new `describe('markConversationRead - readReceipts')` block with these test cases:
   - `it('should write both unreadCount and readReceipts in a single updateDoc call')` -- Mock `updateDoc`, call `markConversationRead('conv1', 'user1')`, assert `updateDoc` was called with an object containing both `unreadCount.user1: 0` and `readReceipts.user1: serverTimestamp()`.
   - `it('should return success true on successful write')` -- Mock `updateDoc` to resolve, assert `result.success === true`.
   - `it('should return success false with error message on failure')` -- Mock `updateDoc` to reject with an error, assert `result.success === false` and `result.error` contains the error message.
   - `it('should return error when conversationId is missing')` -- Call with `(null, 'user1')`, assert `result.success === false`.
   - `it('should return error when userId is missing')` -- Call with `('conv1', null)`, assert `result.success === false`.
3. Follow the existing test pattern: mock functions defined OUTSIDE `jest.mock()`, referenced inside, exported to `global`. Use `require()` for imports after mocks. Use `jest.clearAllMocks()` in `beforeEach`.

**useConversation tests:**

4. Check if `__tests__/hooks/useConversation.test.js` already exists. If not, create it.
5. Follow the existing hook test pattern (see `useDarkroom.test.js` for reference): use `renderHook`, `act`, `waitFor` from `@testing-library/react-native`.
6. Add test cases:
   - `it('should subscribe to conversation document on mount')` -- Mock `onSnapshot` for the conversation document, render the hook, assert `onSnapshot` was called with the conversation doc reference.
   - `it('should expose conversationDoc with readReceipts data')` -- Simulate an onSnapshot callback with a conversation document containing `readReceipts: { user1: { toMillis: () => 1000 } }`, assert `result.current.conversationDoc.readReceipts` is available.
   - `it('should call markConversationRead when unreadCount > 0')` -- Set up conversationDoc with `unreadCount: { currentUser: 2 }`, assert `markConversationRead` was called.
   - `it('should NOT call markConversationRead when unreadCount is 0')` -- Set up conversationDoc with `unreadCount: { currentUser: 0 }`, assert `markConversationRead` was NOT called.
   - `it('should unsubscribe from conversation document on unmount')` -- Mock onSnapshot to return an unsubscribe function, unmount the hook, assert unsubscribe was called.
7. Mock `messageService.markConversationRead` as a jest.fn() for assertion.
8. Mock Firestore `doc`, `onSnapshot` following the existing pattern in jest.setup.js.
   </action>
   <verify>
   <automated>npx jest **tests**/services/messageService.test.js **tests**/hooks/useConversation.test.js --no-coverage 2>&1 | tail -10</automated>
   <manual>Verify all new test cases pass and no existing tests are broken</manual>
   </verify>
   <done> - messageService tests cover: readReceipts write, success/error returns, missing params - useConversation tests cover: conversation doc subscription, readReceipts exposure, first-read-only guard, cleanup - All tests pass (both new and existing) - Test patterns match project conventions (mock outside jest.mock, require after mocks, clearAllMocks in beforeEach)
   </done>
   </task>

</tasks>

<verification>
After all tasks complete:
1. `npx jest __tests__/services/messageService.test.js __tests__/hooks/useConversation.test.js --no-coverage` -- all tests pass
2. `npx jest --no-coverage` -- full test suite passes (no regressions)
3. `npm run lint` -- no linting errors in modified files
4. Review firestore.rules to confirm readReceipts in conversation update allowlist and viewedAt/screenshotted in message update rule
5. Review messageService.js to confirm readReceipts written alongside unreadCount in markConversationRead
6. Review useConversation.js to confirm conversation document onSnapshot subscription with readReceipts exposure and first-read-only guard
7. Review functions/index.js to confirm type field in lastMessage object
</verification>

<success_criteria>

- Firestore rules allow readReceipts field updates on conversation documents (INFRA-02)
- Firestore rules allow viewedAt/screenshotted updates on messages by non-sender participants (INFRA-01)
- markConversationRead atomically writes unreadCount reset + readReceipts timestamp (READ-02)
- useConversation hook provides real-time readReceipts data via conversation document subscription (READ-03)
- First-read-only semantics: readReceipts not overwritten on re-opens when no new messages
- onNewMessage Cloud Function includes type field in lastMessage preview
- All tests pass, no regressions
  </success_criteria>

<output>
After completion, create `.planning/phases/01-message-infrastructure-read-receipts/01-01-SUMMARY.md`
</output>
