---
phase: 03-snap-messages
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/screens/CameraScreen.js
  - src/hooks/useCamera.js
  - src/screens/SnapPreviewScreen.js
autonomous: true
requirements:
  - SNAP-01
  - SNAP-02

must_haves:
  truths:
    - 'CameraScreen accepts a mode:snap route param that hides the darkroom button and photo stack'
    - 'Camera supports flash toggle, camera flip, and both front/rear cameras in snap mode'
    - 'After capture in snap mode, user is navigated to SnapPreviewScreen (not darkroom flow)'
    - 'SnapPreviewScreen shows a Polaroid-framed preview with the recipient name'
    - 'User can type an optional caption (max 150 chars) in the Polaroid bottom strip'
    - 'User can retake via X button or swipe-down to return to camera'
    - 'Pressing send uploads the snap and returns to conversation immediately'
  artifacts:
    - path: 'src/screens/CameraScreen.js'
      provides: 'Snap mode support: hides darkroom UI, routes capture to SnapPreviewScreen'
      contains: 'mode.*snap'
    - path: 'src/screens/SnapPreviewScreen.js'
      provides: 'Polaroid-framed preview with caption input, send button, retake/discard'
      min_lines: 120
    - path: 'src/hooks/useCamera.js'
      provides: 'Snap mode awareness: skip upload queue, return photo URI directly in snap mode'
      contains: 'snap'
  key_links:
    - from: 'src/screens/CameraScreen.js'
      to: 'src/screens/SnapPreviewScreen.js'
      via: 'navigation.navigate with captured photoUri when mode is snap'
      pattern: 'navigate.*SnapPreview'
    - from: 'src/screens/SnapPreviewScreen.js'
      to: 'src/services/firebase/snapService.js'
      via: 'uploadAndSendSnap call on send press'
      pattern: 'uploadAndSendSnap'
    - from: 'src/hooks/useCamera.js'
      to: 'CameraScreen snap mode'
      via: 'mode param changes capture behavior (skip queue, return URI)'
      pattern: 'snap|mode'
---

<objective>
Add snap mode to the existing CameraScreen and build the SnapPreviewScreen. Per locked user decision, this reuses CameraScreen in a "snap mode" rather than creating a separate camera screen.

Purpose: Users need to capture and send snaps from within DM conversations. The camera reuses the existing CameraScreen component with a mode flag that hides darkroom UI and routes captures to the Polaroid preview.
Output: Modified CameraScreen.js with snap mode, modified useCamera.js, new SnapPreviewScreen.js.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-snap-messages/03-CONTEXT.md
@.planning/phases/03-snap-messages/03-RESEARCH.md
@.planning/phases/03-snap-messages/03-01-SUMMARY.md

@src/screens/CameraScreen.js
@src/hooks/useCamera.js
@src/services/firebase/snapService.js
@src/constants/colors.js
@src/constants/typography.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add snap mode to CameraScreen and useCamera hook</name>
  <files>
    src/screens/CameraScreen.js
    src/hooks/useCamera.js
  </files>
  <action>
**Per locked user decision:** "Reuses existing CameraScreen component in a snap mode -- hides darkroom button, keeps flash toggle, camera flip, zoom."

**CameraScreen.js modifications:**

1. Read `mode` from `route.params` (default to `'normal'`):

   ```javascript
   const { mode = 'normal', conversationId, friendId, friendDisplayName } = route.params || {};
   const isSnapMode = mode === 'snap';
   ```

2. **Conditional UI rendering based on isSnapMode:**
   - When `isSnapMode === true`:
     - HIDE the darkroom button / photo stack / card count (the DarkroomBottomSheet and any darkroom-related UI)
     - HIDE the zoom controls (keep snap camera simple per user decision)
     - KEEP flash toggle button (top bar)
     - KEEP camera flip button (bottom bar)
     - KEEP the capture button (center bottom)
     - ADD an X close button (top-left) that calls `navigation.goBack()` to dismiss the modal and return to conversation
   - When `isSnapMode === false`: no changes to existing behavior at all

3. **Modified capture behavior in snap mode:**
   - In snap mode, after `takePictureAsync`, do NOT add to upload queue / darkroom
   - Instead, navigate to SnapPreviewScreen:
     ```javascript
     if (isSnapMode) {
       navigation.navigate('SnapPreviewScreen', {
         photoUri: photo.uri,
         conversationId,
         friendId,
         friendDisplayName,
       });
       return; // Skip normal darkroom flow
     }
     ```
   - Keep existing capture behavior entirely unchanged for normal mode

4. Trigger haptic feedback on capture in snap mode (same as normal mode).

**useCamera.js modifications:**

If the hook manages upload queue logic directly on capture, add snap mode awareness:

- Accept an optional `mode` parameter or `skipQueue` flag
- When `mode === 'snap'` or `skipQueue === true`: the `capturePhoto` function should return the photo URI directly without queueing it in the upload queue
- Do not modify any existing behavior when mode is normal/undefined

Keep changes to useCamera.js minimal. If capture logic is already in CameraScreen (not the hook), the hook changes may be minimal or unnecessary.

**Do NOT create a new SnapCameraModal.js file.** The existing CameraScreen.js is reused per user decision.
</action>
<verify>
<automated>cd "C:/Users/maser/Lapse Clone" && npx jest **tests**/services/snapService.test.js --no-coverage 2>&1 | tail -5</automated>
<manual>Verify CameraScreen.js has snap mode conditional (mode === 'snap'), hides darkroom UI, navigates to SnapPreviewScreen on capture</manual>
</verify>
<done>CameraScreen supports mode='snap' via route params. In snap mode: darkroom button hidden, photo stack hidden, zoom hidden, flash and flip kept, X close button added. Capture navigates to SnapPreviewScreen instead of darkroom queue. Normal mode behavior unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Create SnapPreviewScreen with Polaroid frame and caption</name>
  <files>
    src/screens/SnapPreviewScreen.js
  </files>
  <action>
Create `src/screens/SnapPreviewScreen.js` -- the Polaroid-framed preview shown after capturing a snap photo.

**Layout (per locked user decisions):**

- Full black background, immersive
- "To: [RecipientName]" label at top of screen (using friendDisplayName from route params) in pixel art font
- Centered Polaroid frame containing:
  - Thin white border (8px) on top and sides
  - Captured photo displayed inside the frame with `contentFit="cover"` and 4:3 aspect ratio
  - Thick white strip at bottom (64px height) -- this is where the caption goes
  - Caption is typed directly into the thick bottom strip (WYSIWYG)
  - Use TextInput with pixel art font (Silkscreen_400Regular), placeholder "Write something!" in light gray
  - Max 150 character limit with `maxLength={150}`
  - Polaroid strip always visible even without caption
- X button (top-left) to retake: navigates back to CameraScreen (which stays in snap mode)
- Send button (bottom-right, prominent): large PixelIcon arrow-up on amber/yellow background circle

**Swipe-down gesture to discard:**

- Use `react-native-gesture-handler` PanGesture
- On swipe down past threshold, navigate back to camera (same as X button)
- Use `react-native-reanimated` for translateY animation during gesture

**Send behavior:**

- On press: call `uploadAndSendSnap(conversationId, senderId, photoUri, caption)` from snapService
- While uploading: disable send button, show loading state
- On success: navigate back to conversation screen (pop to ConversationScreen or goBack twice)
- On error: if `result.retriesExhausted`, show Alert with "Failed to send snap" and retry option. Otherwise show generic error.
- After send: return to conversation immediately (no confirmation overlay per user decision)

**Keyboard handling:**

- Use `KeyboardAvoidingView` with `behavior={Platform.select({ ios: 'padding', android: 'height' })}` to prevent keyboard from covering caption input
- Adjust `keyboardVerticalOffset` per platform for proper positioning

**Imports:**

- `useAuth` for senderId (user.uid)
- `uploadAndSendSnap` from snapService
- `expo-image` for photo display with default cachePolicy (this is a preview, not a viewed snap)
- `react-native-reanimated` + `react-native-gesture-handler` for swipe gesture
- `Haptics.notificationAsync` on send
  </action>
  <verify>
  <automated>cd "C:/Users/maser/Lapse Clone" && npx jest **tests**/services/snapService.test.js --no-coverage 2>&1 | tail -5</automated>
  <manual>Verify SnapPreviewScreen.js exists with Polaroid layout, caption TextInput, send button, swipe-down dismiss</manual>
  </verify>
  <done>SnapPreviewScreen shows Polaroid-framed photo with WYSIWYG caption input in the bottom strip, "To: RecipientName" header, retake X button, swipe-down dismiss, and send button that calls snapService.uploadAndSendSnap. Handles retriesExhausted error state. Returns to conversation after send.</done>
  </task>

</tasks>

<verification>
- CameraScreen.js has snap mode support (mode='snap' from route params)
- In snap mode: darkroom hidden, flash/flip kept, capture goes to SnapPreviewScreen
- SnapPreviewScreen.js shows Polaroid frame with caption input
- Both screens handle route params correctly (conversationId, friendId, friendDisplayName)
- Send flow calls uploadAndSendSnap and navigates back to conversation
- Full test suite still passes: `npm test`
</verification>

<success_criteria>

- CameraScreen opens in snap mode with only flash, flip, close, and capture buttons (no darkroom/zoom)
- Captured photo appears in Polaroid frame with white border and thick bottom strip
- Caption input works in the Polaroid strip with 150 char limit
- Send uploads snap via snapService and returns to conversation
- Retake and swipe-down discard work correctly
- "To: RecipientName" shows correct recipient
  </success_criteria>

<output>
After completion, create `.planning/phases/03-snap-messages/03-02-SUMMARY.md`
</output>
