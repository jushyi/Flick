---
phase: 03-snap-messages
plan: 04
type: execute
wave: 3
depends_on:
  - 03-02
  - 03-03
files_modified:
  - src/components/DMInput.js
  - src/components/MessageBubble.js
  - src/screens/ConversationScreen.js
  - src/navigation/AppNavigator.js
  - src/components/ConversationRow.js
  - src/screens/MessagesScreen.js
  - App.js
  - __tests__/components/DMInput.test.js
autonomous: true
requirements:
  - SNAP-01
  - SNAP-04
  - SNAP-06

must_haves:
  truths:
    - 'Camera button replaces send button when text input is empty in DMInput'
    - 'Tapping camera button opens CameraScreen in snap mode for the current conversation'
    - 'Snap messages render as SnapBubble (not regular MessageBubble) in conversation'
    - 'Tapping unopened snap in conversation opens SnapViewer'
    - "Sender sees 'Opened' status after recipient views their snap"
    - 'ConversationRow shows snap camera shortcut button and snap-specific last message preview'
    - 'MessagesScreen passes onSnapCamera callback to ConversationRow'
    - 'CameraScreen (snap mode) and SnapPreviewScreen are registered in navigator'
    - 'Tapping a snap push notification opens conversation with autoOpenSnapId, then auto-opens snap viewer'
  artifacts:
    - path: 'src/components/DMInput.js'
      provides: 'Camera/send button morph with crossfade animation'
      contains: 'handleOpenSnapCamera'
    - path: 'src/components/MessageBubble.js'
      provides: 'Delegates type:snap messages to SnapBubble'
      contains: 'type.*snap'
    - path: 'src/screens/ConversationScreen.js'
      provides: 'SnapViewer integration, snap bubble press handling, optimistic snap state, autoOpenSnapId handling'
      contains: 'SnapViewer'
    - path: 'src/navigation/AppNavigator.js'
      provides: 'SnapPreviewScreen screen registration (CameraScreen already registered, just needs snap mode support)'
      contains: 'SnapPreviewScreen'
    - path: 'src/components/ConversationRow.js'
      provides: 'Snap camera shortcut button and amber unread indicator'
      contains: 'onSnapCamera'
    - path: 'src/screens/MessagesScreen.js'
      provides: 'Passes onSnapCamera callback to ConversationRow for snap camera shortcut navigation'
      contains: 'onSnapCamera'
    - path: 'App.js'
      provides: 'Snap notification handler navigates to Conversation with autoOpenSnapId param'
      contains: 'autoOpenSnapId'
    - path: '__tests__/components/DMInput.test.js'
      provides: 'Tests for camera button when empty, send arrow when typing'
  key_links:
    - from: 'src/components/DMInput.js'
      to: 'src/screens/CameraScreen.js'
      via: 'onOpenSnapCamera callback navigating to CameraScreen with mode:snap'
      pattern: 'onOpenSnapCamera|mode.*snap'
    - from: 'src/screens/ConversationScreen.js'
      to: 'src/components/SnapViewer.js'
      via: 'SnapViewer rendered as overlay, triggered by snap bubble press'
      pattern: 'SnapViewer'
    - from: 'src/components/MessageBubble.js'
      to: 'src/components/SnapBubble.js'
      via: "conditional render when message.type === 'snap'"
      pattern: 'SnapBubble'
    - from: 'src/screens/MessagesScreen.js'
      to: 'src/components/ConversationRow.js'
      via: 'onSnapCamera prop passed to each ConversationRow'
      pattern: 'onSnapCamera'
    - from: 'App.js'
      to: 'src/screens/ConversationScreen.js'
      via: 'notification handler navigates with autoOpenSnapId param'
      pattern: 'autoOpenSnapId'
    - from: 'src/navigation/AppNavigator.js'
      to: 'src/screens/SnapPreviewScreen.js'
      via: 'Stack.Screen registration with slide_from_right presentation'
      pattern: 'SnapPreviewScreen'
---

<objective>
Wire the snap capture flow, viewing experience, and bubble rendering into the existing conversation UI. This integrates all snap components built in Plans 02 and 03 into the live conversation experience, including notification deep linking and conversation list shortcuts.

Purpose: Snap components exist in isolation -- this plan connects them: DMInput camera button opens the camera in snap mode, snap messages render as SnapBubble, tapping opens SnapViewer, ConversationRow shows snap previews with camera shortcut, navigator has all screens registered, and snap notification taps auto-open the viewer.
Output: Modified DMInput, MessageBubble, ConversationScreen, AppNavigator, ConversationRow, MessagesScreen, App.js. New DMInput.test.js.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-snap-messages/03-CONTEXT.md
@.planning/phases/03-snap-messages/03-02-SUMMARY.md
@.planning/phases/03-snap-messages/03-03-SUMMARY.md

@src/components/DMInput.js
@src/components/MessageBubble.js
@src/screens/ConversationScreen.js
@src/navigation/AppNavigator.js
@src/components/ConversationRow.js
@src/screens/MessagesScreen.js
@App.js
@src/components/SnapBubble.js
@src/components/SnapViewer.js
@src/screens/CameraScreen.js
@src/screens/SnapPreviewScreen.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: DMInput camera button morph + Navigator registration + DMInput tests</name>
  <files>
    src/components/DMInput.js
    src/navigation/AppNavigator.js
    __tests__/components/DMInput.test.js
  </files>
  <action>
**DMInput.js modifications (per locked user decisions):**

Add a new prop `onOpenSnapCamera` to DMInput component. This callback is invoked when the camera button is pressed.

Replace the static send button with conditional rendering:

- When `canSend` is true (text has content or media selected): show existing send arrow button (no change)
- When `canSend` is false AND no media selected AND not disabled: show camera button
  - Camera button uses `<PixelIcon name="camera" size={20} color={colors.status.developing} />` (amber color)
  - On press: call `onOpenSnapCamera()`
  - Same styling/size as send button for consistent hit target

**Crossfade animation (per user decision: "subtle crossfade when morphing"):**

- Use RN core `Animated` (per project convention for simple fades)
- Track `canSend` state changes
- Animate opacity: camera icon fades out as send arrow fades in, and vice versa
- Duration: 150-200ms for subtle transition
- Wrap both buttons in Animated.View with opacity driven by the animated value

Keep existing send button logic unchanged. Only add the camera alternative when input is empty.

**AppNavigator.js modifications:**

Add import for SnapPreviewScreen at the top of the file. NOTE: CameraScreen is already registered in the navigator -- it does NOT need a new registration. The snap mode is activated via route params (mode:'snap') when navigating to the existing CameraScreen.

Register SnapPreviewScreen in the root Stack.Navigator (inside the authenticated main app section):

```
<Stack.Screen
  name="SnapPreviewScreen"
  component={SnapPreviewScreen}
  options={{
    headerShown: false,
    presentation: 'fullScreenModal',
    animation: 'slide_from_right',
  }}
/>
```

Place this after the existing modal screens (PhotoDetail, Darkroom, etc.) in the navigator.

If CameraScreen is registered as a tab screen only (not as a modal-presentable screen), also add a separate registration for snap camera use:

```
<Stack.Screen
  name="SnapCamera"
  component={CameraScreen}
  options={{
    headerShown: false,
    presentation: 'fullScreenModal',
    animation: 'slide_from_bottom',
  }}
/>
```

This allows the camera to be presented as a modal from conversations. The `mode: 'snap'` param will be passed via navigation.

**DMInput.test.js (Wave 0 gap closure):**

Create `__tests__/components/DMInput.test.js`:

- Mock all DMInput dependencies (PixelIcon, navigation, etc.)
- Test: when text input is empty and no media, camera button is rendered (not send arrow)
- Test: when text input has content, send arrow is rendered (not camera button)
- Test: when camera button pressed, onOpenSnapCamera callback is called
- Test: when send button pressed, onSend callback is called
- This covers SNAP-01 requirement with automated test
  </action>
  <verify>
  <automated>cd "C:/Users/maser/Lapse Clone" && npx jest **tests**/components/DMInput.test.js **tests**/services/snapService.test.js --no-coverage 2>&1 | tail -15</automated>
  </verify>
  <done>DMInput shows camera button when text is empty with crossfade morph animation. SnapPreviewScreen registered in AppNavigator. CameraScreen accessible as modal for snap mode. DMInput.test.js covers camera/send button morph behavior.</done>
  </task>

<task type="auto">
  <name>Task 2: MessageBubble delegation + ConversationScreen integration + ConversationRow + MessagesScreen + App.js notification</name>
  <files>
    src/components/MessageBubble.js
    src/screens/ConversationScreen.js
    src/components/ConversationRow.js
    src/screens/MessagesScreen.js
    App.js
  </files>
  <action>
**MessageBubble.js modifications:**

At the top of the MessageBubble component, add an early return for snap messages:

```javascript
if (message.type === 'snap') {
  return (
    <SnapBubble
      message={message}
      isCurrentUser={isCurrentUser}
      showTimestamp={showTimestamp}
      onPress={onPress}
      isPending={message._isPending}
      hasError={message._hasError}
      onRetry={message._onRetry}
    />
  );
}
```

Import SnapBubble at the top. This delegates all snap rendering to the dedicated component while keeping the existing MessageBubble logic untouched for other types.

**ConversationScreen.js modifications:**

1. **SnapViewer state management:**
   - Add state: `const [snapViewerMessage, setSnapViewerMessage] = useState(null);`
   - SnapViewer is rendered as a Modal/overlay at the end of the component JSX
   - `<SnapViewer visible={!!snapViewerMessage} snapMessage={snapViewerMessage} conversationId={conversationId} onClose={() => setSnapViewerMessage(null)} />`

2. **Snap bubble press handling:**
   - In the `renderItem` function where MessageBubble props are assembled, for snap messages:
     - If `message.type === 'snap'` AND `message.viewedAt === null` AND message sender is NOT current user: `onPress` opens SnapViewer by calling `setSnapViewerMessage(message)`
     - If snap is already viewed OR sender is current user: `onPress` is undefined (non-interactive)
   - For sender's own snaps: the bubble shows "Delivered" or "Opened" status (handled by SnapBubble internally based on viewedAt)

3. **Optimistic snap support:**
   - Add local state for pending snaps: `const [pendingSnaps, setPendingSnaps] = useState([]);`
   - When a snap is sent from SnapPreviewScreen and user returns to ConversationScreen, the snap should appear optimistically
   - Alternative approach: rely on Firestore real-time subscription (useConversation already provides messages) -- the message will appear within 1-2 seconds of creation. The snap's upload state is tracked by the `_isPending` flag set locally before Firestore confirms.
   - Implementation choice: use a `pendingSnapMessages` array in local state, prepend to messages list, remove when matching messageId appears in subscription data

4. **Camera button handler:**
   - Pass `onOpenSnapCamera` prop to DMInput:

   ```javascript
   onOpenSnapCamera={() => navigation.navigate('SnapCamera', {
     mode: 'snap',
     conversationId,
     friendId,
     friendDisplayName: liveFriendProfile?.displayName || 'Friend',
   })}
   ```

   Note: Navigate to 'SnapCamera' (the modal registration of CameraScreen) NOT to 'Camera' tab.

5. **Auto-open snap from notification (per locked user decision: "Tapping notification: opens the conversation, then automatically opens the snap viewer for the unviewed snap"):**
   - Check `route.params?.autoOpenSnapId` on mount and when messages change
   - If present, find the snap message in the messages list by ID
   - Once found, auto-open SnapViewer after a 300ms delay (to allow conversation to render first)
   - Clear the param after opening to prevent re-triggering
   - Use `useEffect` with dependency on messages to wait for the message to load from Firestore subscription

**ConversationRow.js modifications:**

The existing `getPreviewText()` already handles `type: 'snap'` correctly (Opened/Delivered for sender, "Sent you a snap" for recipient). Add:

1. **Amber unread indicator for snap messages:**
   - When `lastMessage.type === 'snap'` AND conversation has unread count > 0 AND user is not the sender:
   - Change the unread indicator color from cyan to amber (`#F5A623`)
   - Can be done by passing a color prop to UnreadBadge or conditionally styling

2. **Snap camera shortcut button (per user decision: "always-visible snap camera button on each ConversationRow"):**
   - Add a small camera PixelIcon button on the right side of each ConversationRow
   - On press: call `onSnapCamera(conversationId, friendId, friendDisplayName)` prop
   - Size: compact (24x24 tap target with padding), positioned to the right of the timestamp
   - Color: amber/warm yellow to match snap theme
   - **ConversationRow must accept an `onSnapCamera` prop** -- this callback is passed from MessagesScreen

**MessagesScreen.js modifications (CRITICAL -- wires ConversationRow snap camera shortcut):**

In the `renderItem` callback where ConversationRow is rendered, pass an `onSnapCamera` prop:

```javascript
<ConversationRow
  {...existingProps}
  onSnapCamera={(convId, fId, fDisplayName) => {
    navigation.navigate('SnapCamera', {
      mode: 'snap',
      conversationId: convId,
      friendId: fId,
      friendDisplayName: fDisplayName,
    });
  }}
/>
```

This ensures the snap camera shortcut button on each ConversationRow actually navigates to the camera in snap mode. Without this, the shortcut button would have no handler.

**App.js modifications (CRITICAL -- wires snap notification deep link):**

In the existing `handleNotificationTapped` handler (or the notification response listener), add handling for snap-type notifications:

1. Find the section where notification taps are processed (likely in the `useEffect` that sets up `Notifications.addNotificationResponseReceivedListener`)
2. When the notification data contains `type: 'snap'` (or similar indicator from the push notification):
   - Extract `conversationId` and `messageId` (the snap message ID) from notification data
   - Navigate to the Conversation screen with `autoOpenSnapId` param:

   ```javascript
   if (notificationData.type === 'snap') {
     navigationRef.current?.navigate('MainTabs', { screen: 'Messages' });
     setTimeout(() => {
       navigationRef.current?.navigate('Conversation', {
         conversationId: notificationData.conversationId,
         friendId: notificationData.senderId,
         autoOpenSnapId: notificationData.messageId,
       });
     }, 100);
   }
   ```

   - Use the existing two-step navigation pattern (navigate to tab first, then to screen) documented in CLAUDE.md gotcha #4
   - The `autoOpenSnapId` param is then consumed by ConversationScreen (see above) to auto-open the SnapViewer

3. Also update the `onNewMessage` Cloud Function's notification data payload (if not already done in Plan 01) to include `type`, `conversationId`, `senderId`, and `messageId` fields for snap notifications so this handler has the data it needs.
   </action>
   <verify>
   <automated>cd "C:/Users/maser/Lapse Clone" && npx jest **tests**/components/DMInput.test.js **tests**/components/SnapBubble.test.js **tests**/services/snapService.test.js --no-coverage 2>&1 | tail -15</automated>
   <manual>Verify snap messages render as SnapBubble in conversation, tapping opens SnapViewer, ConversationRow shows camera shortcut, MessagesScreen passes onSnapCamera, App.js handles snap notifications with autoOpenSnapId</manual>
   </verify>
   <done>MessageBubble delegates type:snap to SnapBubble. ConversationScreen manages SnapViewer overlay, passes camera callback to DMInput, handles autoOpenSnapId from notifications. ConversationRow has snap camera shortcut button and amber unread indicator. MessagesScreen passes onSnapCamera callback to ConversationRow. App.js handles snap notification taps by navigating with autoOpenSnapId param.</done>
   </task>

</tasks>

<verification>
- DMInput shows camera button when input empty, crossfade to send arrow when typing
- Snap messages in conversation render as SnapBubble (not regular MessageBubble)
- Tapping unopened snap opens SnapViewer
- SnapViewer shows Polaroid frame, marks viewed on dismiss
- ConversationRow shows snap camera shortcut and amber unread indicators
- MessagesScreen passes onSnapCamera callback to ConversationRow (shortcut is functional)
- App.js handles snap notification tap -> navigates to Conversation with autoOpenSnapId -> auto-opens SnapViewer
- CameraScreen (snap mode) and SnapPreviewScreen accessible from navigator
- DMInput.test.js passes with camera/send morph tests
- Full test suite still passes: `npm test`
</verification>

<success_criteria>

- Complete snap sending flow: camera button -> CameraScreen (snap mode) -> capture -> SnapPreviewScreen -> send -> back to conversation
- Complete snap viewing flow: see SnapBubble -> tap -> SnapViewer -> dismiss -> marked as viewed
- Complete notification flow: snap notification -> tap -> conversation opens -> snap viewer auto-opens
- Sender sees Delivered -> Opened transition in real-time
- ConversationRow snap shortcut navigates to snap camera (callback wired from MessagesScreen)
- No regressions in existing text/gif/image messaging
  </success_criteria>

<output>
After completion, create `.planning/phases/03-snap-messages/03-04-SUMMARY.md`
</output>
