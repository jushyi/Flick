---
phase: 03-snap-messages
plan: 04
type: execute
wave: 3
depends_on:
  - 03-02
  - 03-03
files_modified:
  - src/components/DMInput.js
  - src/components/MessageBubble.js
  - src/screens/ConversationScreen.js
  - src/navigation/AppNavigator.js
  - src/components/ConversationRow.js
autonomous: true
requirements:
  - SNAP-01
  - SNAP-04
  - SNAP-06

must_haves:
  truths:
    - 'Camera button replaces send button when text input is empty in DMInput'
    - 'Tapping camera button opens SnapCameraModal for the current conversation'
    - 'Snap messages render as SnapBubble (not regular MessageBubble) in conversation'
    - 'Tapping unopened snap in conversation opens SnapViewer'
    - "Sender sees 'Opened' status after recipient views their snap"
    - 'ConversationRow shows snap camera shortcut button and snap-specific last message preview'
    - 'SnapCameraModal and SnapPreviewScreen are registered in navigator'
  artifacts:
    - path: 'src/components/DMInput.js'
      provides: 'Camera/send button morph with crossfade animation'
      contains: 'handleOpenSnapCamera'
    - path: 'src/components/MessageBubble.js'
      provides: 'Delegates type:snap messages to SnapBubble'
      contains: 'type.*snap'
    - path: 'src/screens/ConversationScreen.js'
      provides: 'SnapViewer integration, snap bubble press handling, optimistic snap state'
      contains: 'SnapViewer'
    - path: 'src/navigation/AppNavigator.js'
      provides: 'SnapCameraModal and SnapPreviewScreen screen registrations'
      contains: 'SnapCameraModal'
    - path: 'src/components/ConversationRow.js'
      provides: 'Snap camera shortcut button and amber unread indicator'
      contains: 'snapCamera'
  key_links:
    - from: 'src/components/DMInput.js'
      to: 'src/screens/SnapCameraModal.js'
      via: 'onOpenSnapCamera callback navigating to SnapCameraModal'
      pattern: 'onOpenSnapCamera|SnapCameraModal'
    - from: 'src/screens/ConversationScreen.js'
      to: 'src/components/SnapViewer.js'
      via: 'SnapViewer rendered as overlay, triggered by snap bubble press'
      pattern: 'SnapViewer'
    - from: 'src/components/MessageBubble.js'
      to: 'src/components/SnapBubble.js'
      via: "conditional render when message.type === 'snap'"
      pattern: 'SnapBubble'
    - from: 'src/navigation/AppNavigator.js'
      to: 'src/screens/SnapCameraModal.js'
      via: 'Stack.Screen registration with slide_from_bottom presentation'
      pattern: 'SnapCameraModal'
---

<objective>
Wire the snap capture flow, viewing experience, and bubble rendering into the existing conversation UI. This integrates all snap components built in Plans 02 and 03 into the live conversation experience.

Purpose: Snap components exist in isolation -- this plan connects them: DMInput camera button opens the camera, snap messages render as SnapBubble, tapping opens SnapViewer, ConversationRow shows snap previews, and navigator has all screens registered.
Output: Modified DMInput, MessageBubble, ConversationScreen, AppNavigator, ConversationRow.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-snap-messages/03-CONTEXT.md
@.planning/phases/03-snap-messages/03-02-SUMMARY.md
@.planning/phases/03-snap-messages/03-03-SUMMARY.md

@src/components/DMInput.js
@src/components/MessageBubble.js
@src/screens/ConversationScreen.js
@src/navigation/AppNavigator.js
@src/components/ConversationRow.js
@src/components/SnapBubble.js
@src/components/SnapViewer.js
@src/screens/SnapCameraModal.js
@src/screens/SnapPreviewScreen.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: DMInput camera button morph + Navigator registration</name>
  <files>
    src/components/DMInput.js
    src/navigation/AppNavigator.js
  </files>
  <action>
**DMInput.js modifications (per locked user decisions):**

Add a new prop `onOpenSnapCamera` to DMInput component. This callback is invoked when the camera button is pressed.

Replace the static send button with conditional rendering:

- When `canSend` is true (text has content or media selected): show existing send arrow button (no change)
- When `canSend` is false AND no media selected AND not disabled: show camera button
  - Camera button uses `<PixelIcon name="camera" size={20} color={colors.status.developing} />` (amber color)
  - On press: call `onOpenSnapCamera()`
  - Same styling/size as send button for consistent hit target

**Crossfade animation (per user decision: "subtle crossfade when morphing"):**

- Use RN core `Animated` (per project convention for simple fades)
- Track `canSend` state changes
- Animate opacity: camera icon fades out as send arrow fades in, and vice versa
- Duration: 150-200ms for subtle transition
- Wrap both buttons in Animated.View with opacity driven by the animated value

Keep existing send button logic unchanged. Only add the camera alternative when input is empty.

**AppNavigator.js modifications:**

Add imports for SnapCameraModal and SnapPreviewScreen at the top of the file.

Register two new screens in the root Stack.Navigator (inside the authenticated main app section):

```
<Stack.Screen
  name="SnapCameraModal"
  component={SnapCameraModal}
  options={{
    headerShown: false,
    presentation: 'fullScreenModal',
    animation: 'slide_from_bottom',
  }}
/>
<Stack.Screen
  name="SnapPreviewScreen"
  component={SnapPreviewScreen}
  options={{
    headerShown: false,
    presentation: 'fullScreenModal',
    animation: 'slide_from_right',
  }}
/>
```

Place these after the existing modal screens (PhotoDetail, Darkroom, etc.) in the navigator.
</action>
<verify>
<automated>cd "C:/Users/maser/Lapse Clone" && npx jest --passWithNoTests --no-coverage 2>&1 | tail -5</automated>
<manual>Verify DMInput shows camera icon when input is empty, send arrow when typing. Both screens registered in navigator.</manual>
</verify>
<done>DMInput shows camera button when text is empty with crossfade morph animation. SnapCameraModal and SnapPreviewScreen registered in AppNavigator with correct modal presentations.</done>
</task>

<task type="auto">
  <name>Task 2: MessageBubble snap delegation + ConversationScreen SnapViewer integration + ConversationRow updates</name>
  <files>
    src/components/MessageBubble.js
    src/screens/ConversationScreen.js
    src/components/ConversationRow.js
  </files>
  <action>
**MessageBubble.js modifications:**

At the top of the MessageBubble component, add an early return for snap messages:

```javascript
if (message.type === 'snap') {
  return (
    <SnapBubble
      message={message}
      isCurrentUser={isCurrentUser}
      showTimestamp={showTimestamp}
      onPress={onPress}
      isPending={message._isPending}
    />
  );
}
```

Import SnapBubble at the top. This delegates all snap rendering to the dedicated component while keeping the existing MessageBubble logic untouched for other types.

**ConversationScreen.js modifications:**

1. **SnapViewer state management:**
   - Add state: `const [snapViewerMessage, setSnapViewerMessage] = useState(null);`
   - SnapViewer is rendered as a Modal/overlay at the end of the component JSX
   - `<SnapViewer visible={!!snapViewerMessage} snapMessage={snapViewerMessage} conversationId={conversationId} onClose={() => setSnapViewerMessage(null)} />`

2. **Snap bubble press handling:**
   - In the `renderItem` function where MessageBubble props are assembled, for snap messages:
     - If `message.type === 'snap'` AND `message.viewedAt === null` AND message sender is NOT current user: `onPress` opens SnapViewer by calling `setSnapViewerMessage(message)`
     - If snap is already viewed OR sender is current user: `onPress` is undefined (non-interactive)
   - For sender's own snaps: the bubble shows "Delivered" or "Opened" status (handled by SnapBubble internally based on viewedAt)

3. **Optimistic snap support:**
   - Add local state for pending snaps: `const [pendingSnaps, setPendingSnaps] = useState([]);`
   - When a snap is sent from SnapPreviewScreen and user returns to ConversationScreen, the snap should appear optimistically
   - Alternative approach: rely on Firestore real-time subscription (useConversation already provides messages) -- the message will appear within 1-2 seconds of creation. The snap's upload state is tracked by the `_isPending` flag set locally before Firestore confirms.
   - Implementation choice: use a `pendingSnapMessages` array in local state, prepend to messages list, remove when matching messageId appears in subscription data

4. **Camera button handler:**
   - Pass `onOpenSnapCamera` prop to DMInput:

   ```javascript
   onOpenSnapCamera={() => navigation.navigate('SnapCameraModal', {
     conversationId,
     friendId,
     friendDisplayName: liveFriendProfile?.displayName || 'Friend',
   })}
   ```

5. **Auto-open snap from notification (per user decision):**
   - Check `route.params.autoOpenSnapId` on mount
   - If present, find the snap message in the messages list and auto-open SnapViewer after a 300ms delay
   - Use `useEffect` with dependency on messages to wait for the message to load

**ConversationRow.js modifications:**

The existing `getPreviewText()` already handles `type: 'snap'` correctly (Opened/Delivered for sender, "Sent you a snap" for recipient). Add:

1. **Amber unread indicator for snap messages:**
   - When `lastMessage.type === 'snap'` AND conversation has unread count > 0 AND user is not the sender:
   - Change the unread indicator color from cyan to amber (`#F5A623`)
   - Can be done by passing a color prop to UnreadBadge or conditionally styling

2. **Snap camera shortcut button (per user decision: "always-visible snap camera button on each ConversationRow"):**
   - Add a small camera PixelIcon button on the right side of each ConversationRow
   - On press: navigate to SnapCameraModal with the conversation's friendId and conversationId
   - Size: compact (24x24 tap target with padding), positioned to the right of the timestamp
   - Color: amber/warm yellow to match snap theme
   - This requires ConversationRow to have access to navigation -- pass `onSnapCamera` callback prop from MessagesScreen/parent
     </action>
     <verify>
     <automated>cd "C:/Users/maser/Lapse Clone" && npx jest --passWithNoTests --no-coverage 2>&1 | tail -5</automated>
     <manual>Verify snap messages render as SnapBubble in conversation, tapping opens SnapViewer, ConversationRow shows camera shortcut</manual>
     </verify>
     <done>MessageBubble delegates type:snap to SnapBubble. ConversationScreen manages SnapViewer overlay and passes camera callback to DMInput. ConversationRow has snap camera shortcut button and amber unread indicator. Navigator has all snap screens registered.</done>
     </task>

</tasks>

<verification>
- DMInput shows camera button when input empty, crossfade to send arrow when typing
- Snap messages in conversation render as SnapBubble (not regular MessageBubble)
- Tapping unopened snap opens SnapViewer
- SnapViewer shows Polaroid frame, marks viewed on dismiss
- ConversationRow shows snap camera shortcut and amber unread indicators
- SnapCameraModal and SnapPreviewScreen accessible from navigator
- Full test suite still passes: `npm test`
</verification>

<success_criteria>

- Complete snap sending flow: camera button -> SnapCameraModal -> capture -> SnapPreviewScreen -> send -> back to conversation
- Complete snap viewing flow: see SnapBubble -> tap -> SnapViewer -> dismiss -> marked as viewed
- Sender sees Delivered -> Opened transition in real-time
- ConversationRow snap shortcut and amber unread work
- No regressions in existing text/gif/image messaging
  </success_criteria>

<output>
After completion, create `.planning/phases/03-snap-messages/03-04-SUMMARY.md`
</output>
