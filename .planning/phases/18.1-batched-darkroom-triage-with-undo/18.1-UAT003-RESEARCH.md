# UAT-003: Black Flash During Card Transitions - Research

**Researched:** 2026-01-23
**Domain:** React Native Image caching + Reanimated animation timing
**Confidence:** HIGH
**Issue:** UAT-003 - Black flash visible during card cascade transitions (forward swipe and undo)

<research_summary>
## Summary

Researched the React Native image loading ecosystem to resolve the persistent black flash during card triage animations. The root cause is **image rendering delay** - when a stack card moves to the front position (scales up), the Image component needs time to decode/render at the larger size. The blur overlay fades before the image finishes rendering, exposing the black background.

The app currently uses React Native's built-in `Image` component which has:
- Unreliable caching (emulates browser caching via HTTP headers)
- UI thread blocking during resize/decode
- No built-in transition handling
- Race conditions with onLoadEnd callbacks

**Primary recommendation:** Migrate from React Native `Image` to `expo-image` which provides:
- Native caching (SDWebImage on iOS, Glide on Android)
- Built-in transition prop that eliminates flickering
- Prefetch API for preloading stack card images
- Memory-disk caching policy for instant re-renders
</research_summary>

<standard_stack>
## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| expo-image | ~2.0.x | Image component | Built-in caching, transitions, prefetch - eliminates flicker |
| react-native-reanimated | ~4.1.1 | Animations | Already in use, provides 60fps animations |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Image.prefetch() | expo-image API | Preload images | Before animations to cache stack images |
| blurhash | Built into expo-image | Placeholder | Low-data placeholder while loading |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| expo-image | react-native-fast-image | FastImage unmaintained since 2022, requires native patches for flicker fix |
| expo-image | RN Image + workarounds | More code, less reliable, no built-in transitions |
| expo-image transition | Manual opacity animation | expo-image handles this automatically and better |

**Installation:**
```bash
npx expo install expo-image
```
</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Pattern 1: expo-image with Built-in Transition
**What:** Use expo-image's transition prop instead of managing blur overlay manually
**When to use:** Any image that changes visibility or animates into view
**Example:**
```typescript
// Source: expo-image official docs
import { Image } from 'expo-image';

<Image
  source={{ uri: photo.imageURL }}
  style={styles.photoImage}
  contentFit="cover"
  transition={200}  // 200ms cross-dissolve, prevents any flash
  cachePolicy="memory-disk"  // Fast re-renders from memory, persists to disk
/>
```

### Pattern 2: Prefetch Stack Card Images
**What:** Preload all visible stack card images when darkroom opens
**When to use:** When displaying a card stack where cards will animate to front
**Example:**
```typescript
// Source: expo-image prefetch API
import { Image } from 'expo-image';

// In DarkroomScreen, when photos load:
useEffect(() => {
  if (photos.length > 0) {
    // Prefetch first 3 cards (visible in stack)
    const urlsToPreload = photos.slice(0, 3).map(p => p.imageURL);
    Image.prefetch(urlsToPreload, 'memory-disk');
  }
}, [photos]);
```

### Pattern 3: Remove Manual Blur Overlay (Simplification)
**What:** Remove stackBlurOverlay since expo-image transition handles this natively
**When to use:** After migrating to expo-image
**Rationale:**
- Current blur overlay (200ms timing) was a workaround for RN Image rendering delay
- expo-image's transition prop handles the visual smoothness automatically
- Removes animation complexity and potential timing mismatches

### Anti-Patterns to Avoid
- **Using RN Image for animated content:** Built-in Image has no transition support, causes flicker
- **Manual opacity animations on images:** Race conditions with onLoadEnd, use library's transition instead
- **Not prefetching visible stack images:** Forces decode on-demand, causes delay
- **Using `key` prop to force remount:** Triggers fresh download, worse than caching
</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Image transition smoothness | Manual blur overlay + timing | expo-image transition prop | Library handles decode timing, cross-fade, race conditions |
| Image caching | HTTP headers / manual cache | expo-image cachePolicy | Native SDWebImage/Glide far more reliable than JS solutions |
| Stack card preloading | Manual Image.prefetch + state tracking | expo-image Image.prefetch() | Returns promise, handles errors, integrates with cache |
| Preventing re-render flash | Array manipulation avoidance | expo-image recycling behavior | Designed for this exact problem in FlashList/FlatList |

**Key insight:** The black flash is a **solved problem** in expo-image. The library was specifically designed to eliminate flickering when image sources change or images animate into view. Fighting React Native's Image component with workarounds (blur overlays, timing animations) will never be as reliable as using a library built to solve this.
</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Late onLoadEnd Callbacks (Race Condition)
**What goes wrong:** Previous image's onLoadEnd fires after new image shown, corrupts state
**Why it happens:** RN Image doesn't cancel pending loads when source changes
**How to avoid:** Use expo-image which handles this internally, or use `key` prop (but key causes re-download)
**Warning signs:** Flash happens specifically when swiping quickly, inconsistent timing

### Pitfall 2: Decode Happening During Animation
**What goes wrong:** Image decoding blocks UI thread, animation stutters or flashes
**Why it happens:** RN Image decodes synchronously on main thread when image scales
**How to avoid:** Prefetch images at full resolution before they're needed in animation
**Warning signs:** Flash severity varies by image size, worse on older devices

### Pitfall 3: Memory Pressure Evicts Cache
**What goes wrong:** Image was cached but got evicted, re-downloads during animation
**Why it happens:** Memory-only cache evicted under pressure, disk cache not checked fast enough
**How to avoid:** Use `memory-disk` cache policy to ensure disk fallback is instant
**Warning signs:** Flash appears randomly after app running a while, not reproducible

### Pitfall 4: Transition Timing Mismatch
**What goes wrong:** Blur overlay fades at different rate than image appears
**Why it happens:** Separate animation systems (Reanimated for overlay, Image decode for image)
**How to avoid:** Use single transition system (expo-image transition) instead of coordinating two
**Warning signs:** Flash worse on some devices, timing-dependent issues
</common_pitfalls>

<code_examples>
## Code Examples

Verified patterns from official sources:

### Basic expo-image Migration
```typescript
// Source: https://docs.expo.dev/versions/latest/sdk/image/
// BEFORE (React Native Image - causes flash):
import { Image } from 'react-native';

<Image
  source={{ uri: photo.imageURL }}
  style={styles.photoImage}
  resizeMode="cover"
  fadeDuration={0}
/>

// AFTER (expo-image - no flash):
import { Image } from 'expo-image';

<Image
  source={{ uri: photo.imageURL }}
  style={styles.photoImage}
  contentFit="cover"
  transition={200}
  cachePolicy="memory-disk"
/>
```

### Prefetching Stack Images on Mount
```typescript
// Source: https://docs.expo.dev/versions/latest/sdk/image/
import { Image } from 'expo-image';

// In DarkroomScreen.js
useEffect(() => {
  const prefetchStackImages = async () => {
    if (photos.length === 0) return;

    // Prefetch visible stack cards (first 3-4)
    const visiblePhotos = photos.filter(p => !hiddenPhotoIds.has(p.id)).slice(0, 4);
    const urls = visiblePhotos.map(p => p.imageURL);

    try {
      await Image.prefetch(urls, 'memory-disk');
      logger.debug('Prefetched stack images', { count: urls.length });
    } catch (error) {
      logger.warn('Failed to prefetch some images', { error });
    }
  };

  prefetchStackImages();
}, [photos, hiddenPhotoIds]);
```

### Simplified SwipeablePhotoCard (After Migration)
```typescript
// Source: Adaptation based on expo-image docs
// Key changes after migration:

// 1. Remove blur overlay state and animation
// REMOVE: const stackBlurOpacityAnim = useSharedValue(getStackBlurOpacity(stackIndex));

// 2. Remove blur overlay animated style
// REMOVE: const stackBlurStyle = useAnimatedStyle(() => ({ opacity: stackBlurOpacityAnim.value }));

// 3. Remove blur overlay View from render
// REMOVE: <Animated.View style={[styles.stackBlurOverlay, stackBlurStyle]} />

// 4. expo-image handles smooth appearance automatically via transition prop
<Image
  source={{ uri: photo.imageURL }}
  style={styles.photoImage}
  contentFit="cover"
  transition={200}  // This replaces the blur overlay functionality
  cachePolicy="memory-disk"
/>
```

### Handling Undo Animation with Preloaded Images
```typescript
// When undoing, the previously-hidden card needs to animate back
// Since images are prefetched, this should be smooth:

const handleUndo = () => {
  if (undoStack.length === 0) return;

  const lastDecision = undoStack[undoStack.length - 1];

  // Image already in cache from initial prefetch
  // expo-image will render instantly from memory-disk cache
  setHiddenPhotoIds(prev => {
    const newHidden = new Set(prev);
    newHidden.delete(lastDecision.photoId);
    return newHidden;
  });

  // Trigger reverse animation
  // ...
};
```
</code_examples>

<sota_updates>
## State of the Art (2024-2025)

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| react-native-fast-image | expo-image | 2023 | FastImage unmaintained, expo-image actively developed |
| Manual blur overlay timing | expo-image transition prop | 2023 | Native handling eliminates timing issues |
| RN Image + fadeDuration=0 | expo-image + transition | 2023 | fadeDuration only prevents fade-in, doesn't help with re-renders |
| HTTP header caching | Native SDWebImage/Glide | 2020+ | Much more reliable cache hits |

**New tools/patterns to consider:**
- **expo-image blurhash placeholder:** Show compact placeholder while loading, eliminates any flash perception
- **Image.getCachePathAsync():** Check if image is cached before animation, add loading state if not
- **recyclingKey prop:** For FlashList/FlatList, ensures proper image cleanup on recycle

**Deprecated/outdated:**
- **react-native-fast-image:** Last real update 2022, requires native patches for flicker fix
- **Manual Image.prefetch() from RN:** Less reliable than expo-image version
- **Custom blur overlay timing animations:** Unnecessary with expo-image transition
</sota_updates>

<open_questions>
## Open Questions

Things that couldn't be fully resolved:

1. **Exact transition duration for smooth cascade**
   - What we know: 200ms is expo-image default, works for most cases
   - What's unclear: May need tuning to match existing 400ms swipe exit duration
   - Recommendation: Start with 200ms, tune during implementation if needed

2. **Memory usage with 4 prefetched full-res images**
   - What we know: expo-image uses native caching which is memory-efficient
   - What's unclear: Impact on older devices with limited RAM
   - Recommendation: Use `memory-disk` policy (not pure `memory`) for safety

3. **Interaction with existing Reanimated animations**
   - What we know: expo-image transition is separate from Reanimated
   - What's unclear: Whether both systems animating simultaneously causes issues
   - Recommendation: Test with existing cascade animation, should be independent
</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- [Expo Image Documentation](https://docs.expo.dev/versions/latest/sdk/image/) - Prefetch API, cachePolicy, transition prop
- [React Native Image Docs](https://reactnative.dev/docs/0.73/image) - Current RN Image limitations

### Secondary (MEDIUM confidence)
- [React Native Image Optimization (Medium)](https://medium.com/@engin.bolat/react-native-image-optimization-performance-essentials-9e8ce6a1193e) - Comparison of RN Image vs expo-image vs FastImage
- [LogRocket Caching Tutorial](https://blog.logrocket.com/caching-images-react-native-tutorial-with-examples/) - Caching strategies overview
- [Sensical Image Prefetching](https://hailey.at/posts/3kq3ddr7c3c23) - Prefetch batching strategies

### Tertiary (LOW confidence - needs validation)
- GitHub Issues on flickering (#17446, #2570, #981) - Community workarounds, some outdated
</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: React Native Image â†’ expo-image migration
- Ecosystem: expo-image prefetch, caching, transitions
- Patterns: Prefetch on mount, remove manual blur overlay
- Pitfalls: Race conditions, decode blocking, cache eviction

**Confidence breakdown:**
- Standard stack: HIGH - expo-image is documented Expo recommendation
- Architecture: HIGH - Patterns from official docs
- Pitfalls: HIGH - Well-documented in React Native GitHub issues
- Code examples: HIGH - Adapted from official expo-image documentation

**Research date:** 2026-01-23
**Valid until:** 2026-02-23 (30 days - expo-image ecosystem stable)
</metadata>

---

## Recommended Fix Approach

Based on research, the fix for UAT-003 should:

1. **Install expo-image** (`npx expo install expo-image`)

2. **Migrate SwipeablePhotoCard.js:**
   - Replace `import { Image } from 'react-native'` with `import { Image } from 'expo-image'`
   - Add `transition={200}` and `cachePolicy="memory-disk"` props
   - Remove stackBlurOverlay and all related animation code (no longer needed)

3. **Add prefetching to DarkroomScreen.js:**
   - Prefetch first 4 visible stack images when photos load
   - Re-prefetch when hiddenPhotoIds changes (new front card)

4. **Simplification benefit:**
   - Remove ~50 lines of blur overlay animation code
   - Simpler mental model (expo-image handles transitions)
   - More reliable across devices and image sizes

**Estimated complexity:** Low-Medium (mostly replacement, some code removal)

---

*Phase: 18.1-batched-darkroom-triage-with-undo*
*Issue: UAT-003*
*Research completed: 2026-01-23*
*Ready for planning: yes*
