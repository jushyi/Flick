---
phase: 10-pinned-snaps-android
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/notifications/sender.js
  - functions/index.js
  - src/services/firebase/notificationService.js
  - __tests__/services/notificationService.test.js
autonomous: true
requirements:
  - PINA-01
  - PINA-02

must_haves:
  truths:
    - "When a snap with isPinned:true is created, the cloud function sends a push notification with richContent.image containing a signed URL thumbnail"
    - "The pinned snap notification uses the dedicated pinned-snaps Android channel with HIGH importance"
    - "Tapping a pinned snap notification navigates to the Conversation screen with autoOpenSnapId"
  artifacts:
    - path: "functions/notifications/sender.js"
      provides: "Extended sendPushNotification accepting richContent and channelId params"
      contains: "richContent"
    - path: "functions/index.js"
      provides: "Pinned snap branch in onNewMessage with signed URL generation and richContent push"
      contains: "isPinned"
    - path: "src/services/firebase/notificationService.js"
      provides: "pinned-snaps channel creation + pinned_snap handler in handleNotificationTapped"
      contains: "pinned-snaps"
    - path: "__tests__/services/notificationService.test.js"
      provides: "Tests for pinned_snap notification type handler and channel creation"
      contains: "pinned_snap"
  key_links:
    - from: "functions/index.js"
      to: "functions/notifications/sender.js"
      via: "sendPushNotification call with richContent param"
      pattern: "sendPushNotification.*richContent"
    - from: "functions/index.js"
      to: "Firebase Storage"
      via: "getSignedUrl for snap thumbnail with 30-minute expiry"
      pattern: "getSignedUrl"
    - from: "src/services/firebase/notificationService.js"
      to: "Conversation screen"
      via: "handleNotificationTapped pinned_snap case returning autoOpenSnapId"
      pattern: "case 'pinned_snap'"
---

<objective>
Set up the server-side pinned snap push notification pipeline and client-side notification handling infrastructure.

Purpose: When a pinned snap message is created, the cloud function must detect isPinned, generate a 30-minute signed URL for the snap thumbnail, and send a push notification with richContent.image (Android BigPictureStyle). The client must create the pinned-snaps Android notification channel and handle pinned_snap notification taps to navigate to the conversation with auto-open snap behavior.

Output: Cloud function pinned snap push notifications with thumbnail + client notification channel and tap handler
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-pinned-snaps-android/10-CONTEXT.md
@.planning/phases/10-pinned-snaps-android/10-RESEARCH.md

@functions/notifications/sender.js
@functions/index.js
@src/services/firebase/notificationService.js
@__tests__/services/notificationService.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend sendPushNotification and add client notification infrastructure</name>
  <files>
    functions/notifications/sender.js
    src/services/firebase/notificationService.js
    __tests__/services/notificationService.test.js
  </files>
  <action>
1. **functions/notifications/sender.js** — Extend `sendPushNotification` to accept two new optional params: `richContent` (object, default null) and `channelId` (string, default 'default'):
   - Update function signature: `async function sendPushNotification(token, title, body, data = {}, userId = null, richContent = null)`
   - In the message object construction, add: `channelId: data.channelId || 'default'` (use channelId from data payload if present, otherwise default)
   - If `richContent` is not null, spread it into the message: `...(richContent ? { richContent } : {})`
   - IMPORTANT: Expo Push API requires array format for richContent processing. The existing code already uses `sendPushNotificationsAsync([message])` (array syntax), so this is already correct. Do NOT change to single-message format.
   - Update the JSDoc to document the new params.

2. **src/services/firebase/notificationService.js** — Two changes:
   a) In `initializeNotifications()`, after the existing 'default' channel setup block (inside the `Platform.OS === 'android'` check), add a new channel:
      ```javascript
      await Notifications.setNotificationChannelAsync('pinned-snaps', {
        name: 'Pinned Snaps',
        importance: Notifications.AndroidImportance.HIGH,
        vibrationPattern: [0, 250, 250, 250],
        lightColor: '#000000',
        description: 'Photo snaps pinned to your notification shade',
        sound: 'default',
      });
      ```
   b) In `handleNotificationTapped()`, add a new case `'pinned_snap'` in the switch statement, right after the existing `case 'snap'` block. The handler should return the exact same structure as the `'snap'` case — navigating to Conversation with conversationId, friendId (senderId), friendProfile, and autoOpenSnapId (messageId). Copy the snap case and change the type field to 'pinned_snap'.

3. **__tests__/services/notificationService.test.js** — Add test cases at the end of the file:
   a) A describe block `'pinned-snaps channel'` that tests initializeNotifications creates the pinned-snaps channel on Android (mock Platform.OS = 'android', call initializeNotifications, verify setNotificationChannelAsync was called with 'pinned-snaps' and correct config).
   b) A describe block `'pinned_snap notification type'` that tests handleNotificationTapped correctly routes pinned_snap notifications to Conversation screen with autoOpenSnapId. Create a mock notification with `data: { type: 'pinned_snap', conversationId: 'conv123', senderId: 'user456', senderName: 'Alice', senderProfilePhotoURL: '', messageId: 'msg789' }`, call handleNotificationTapped, and assert the returned data matches the expected navigation params.
  </action>
  <verify>
    <automated>cd "C:/Users/maser/Lapse Clone" && npx jest __tests__/services/notificationService.test.js --no-coverage 2>&1 | tail -20</automated>
    <manual>Verify sender.js exports unchanged (sendPushNotification, sendBatchNotifications, expo), new params are optional and backward-compatible</manual>
  </verify>
  <done>
    - sendPushNotification accepts optional richContent and uses channelId from data payload
    - pinned-snaps Android notification channel is created in initializeNotifications
    - handleNotificationTapped routes pinned_snap type to Conversation with autoOpenSnapId
    - Tests pass for channel creation and notification tap handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pinned snap branch in onNewMessage cloud function</name>
  <files>
    functions/index.js
  </files>
  <action>
In `functions/index.js`, modify the `onNewMessage` trigger's push notification section (around line 3068-3114). Currently the snap notification flow sends a standard push. Add a branch that detects `isPinned` snaps and sends a richContent push instead:

1. After the existing `body` variable is set for snap messages (~line 3071), add the pinned snap detection and thumbnail URL generation:
   ```javascript
   // Pinned snap: generate thumbnail signed URL and send richContent notification
   if (messageType === 'snap' && message.isPinned) {
     try {
       const file = admin.storage().bucket().file(message.snapStoragePath);
       const [thumbnailUrl] = await file.getSignedUrl({
         action: 'read',
         expires: Date.now() + 30 * 60 * 1000, // 30 minutes for notification delivery
       });

       const pinnedNotificationData = {
         type: 'pinned_snap',
         conversationId,
         senderId,
         senderName,
         senderProfilePhotoURL: senderPhotoURL || '',
         messageId: context.params.messageId,
         threadId: conversationId,
         channelId: 'pinned-snaps',
       };

       await sendPushNotification(
         fcmToken,
         `Pinned snap from ${senderName}`,
         message.caption || 'Tap to view',
         pinnedNotificationData,
         recipientId,
         { image: thumbnailUrl }
       );

       logger.info('onNewMessage: Pinned snap notification sent with thumbnail', {
         conversationId,
         messageId: context.params.messageId,
       });
     } catch (pinnedError) {
       logger.error('onNewMessage: Pinned snap notification failed, falling back to standard', {
         error: pinnedError.message,
         conversationId,
       });
       // Fall back to standard snap notification
       await sendPushNotification(fcmToken, senderName, body, notificationData, recipientId);
     }
   } else {
     // Standard notification (non-pinned snaps + all other types)
     await sendPushNotification(fcmToken, senderName, body, notificationData, recipientId);
   }
   ```

2. Move the existing `await sendPushNotification(fcmToken, senderName, body, notificationData, recipientId);` call (line 3114) inside the `else` branch of the new conditional, so it only fires for non-pinned messages.

3. The notification title for pinned snaps is `"Pinned snap from {senderName}"` per user decision. The body is `message.caption || 'Tap to view'` per user decision. The channelId is `'pinned-snaps'`.

4. The signed URL uses 30-minute expiry (not the standard 5-minute) to account for FCM delivery latency per research pitfall #1.

5. IMPORTANT: The `message.isPinned` field does not exist yet on snap messages (that comes in Plan 02). This is fine — `message.isPinned` will be `undefined` which is falsy, so the existing notification flow is unchanged until Plan 02 adds the field. This is intentional forward-compatible design.

6. Do NOT create separate tests for this in the functions test suite — the cloud function tests use a complex mock setup and the isPinned field will only be testable after Plan 02 adds it to snapService. The verification is that the existing onNewMessage tests still pass (no regressions).
  </action>
  <verify>
    <automated>cd "C:/Users/maser/Lapse Clone/functions" && npx jest --no-coverage 2>&1 | tail -20</automated>
    <manual>Read the modified onNewMessage section and verify: (1) isPinned branch generates 30-minute signed URL, (2) uses richContent param, (3) falls back to standard notification on error, (4) existing non-pinned flow unchanged</manual>
  </verify>
  <done>
    - onNewMessage detects isPinned snaps and sends push with richContent.image thumbnail
    - Signed URL has 30-minute expiry for delivery reliability
    - Error fallback sends standard snap notification if thumbnail generation fails
    - Existing functions tests pass with no regressions (isPinned field is undefined for existing snaps = falsy = standard path)
  </done>
</task>

</tasks>

<verification>
1. `npx jest __tests__/services/notificationService.test.js --no-coverage` — all tests pass including new pinned_snap cases
2. `cd functions && npx jest --no-coverage` — all existing cloud function tests pass (no regressions)
3. `npm run lint` — no linting errors in modified files
</verification>

<success_criteria>
- sendPushNotification accepts richContent param and passes it to Expo Push API
- pinned-snaps Android notification channel is created on app init
- handleNotificationTapped routes pinned_snap type to Conversation with autoOpenSnapId
- onNewMessage cloud function detects isPinned snaps and sends BigPictureStyle push with 30-minute signed URL thumbnail
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/10-pinned-snaps-android/10-01-SUMMARY.md`
</output>
