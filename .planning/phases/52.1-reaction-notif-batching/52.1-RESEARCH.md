# Phase 52.1: Fix Reaction Notification Batching - Research

**Researched:** 2026-02-13
**Domain:** Firebase Cloud Functions stateless batching with Firestore
**Confidence:** HIGH

<research_summary>

## Summary

Researched the Firebase Cloud Functions ecosystem for implementing notification batching in a stateless serverless environment. The root problem is that Cloud Functions are stateless‚Äîeach photo update can trigger a separate function instance with its own memory space. The current in-memory `pendingReactions` object doesn't persist across instances, causing duplicate notifications instead of proper batching.

The standard approach uses **Firestore documents as the source of truth** for pending batches, replacing in-memory state entirely. Firestore transactions provide atomic read-modify-write operations that prevent race conditions, while Cloud Tasks or Firestore TTL handle time-window expiration and cleanup.

Key finding: Don't use in-memory state for batching in Cloud Functions. Firestore transactions guarantee exactly-once processing even with concurrent updates. The batching pattern is: check for existing batch document ‚Üí create or update via transaction ‚Üí schedule cleanup with Cloud Tasks or rely on TTL.

**Primary recommendation:** Replace `pendingReactions` object with Firestore `reactionBatches` collection. Use transactions for atomic batch updates, Cloud Tasks for 30-second delayed notification sends, and Firestore TTL for automatic cleanup of processed batches.
</research_summary>

<standard_stack>

## Standard Stack

The established libraries/tools for serverless notification batching:

### Core

| Library                 | Version  | Purpose                               | Why Standard                                                           |
| ----------------------- | -------- | ------------------------------------- | ---------------------------------------------------------------------- |
| firebase-admin          | 12.x     | Firebase Admin SDK for Node.js        | Official SDK for Cloud Functions, required for all Firebase operations |
| @google-cloud/firestore | Built-in | Firestore database client             | Included with firebase-admin, provides transactions and batch writes   |
| @google-cloud/tasks     | 5.x      | Cloud Tasks API for delayed execution | Google's managed task queue, built for serverless delayed processing   |

### Supporting

| Library                 | Version | Purpose                               | When to Use                                                |
| ----------------------- | ------- | ------------------------------------- | ---------------------------------------------------------- |
| firebase-functions      | 5.x     | Cloud Functions framework             | Already in use, provides triggers and lifecycle management |
| firebase-functions-test | 3.x     | Testing utilities for Cloud Functions | Existing dev dependency, useful for testing batching logic |

### Alternatives Considered

| Instead of   | Could Use                              | Tradeoff                                                                                |
| ------------ | -------------------------------------- | --------------------------------------------------------------------------------------- |
| Cloud Tasks  | Firestore TTL                          | TTL deletes within 24-72h (too slow for 30s window), Cloud Tasks executes at exact time |
| Transactions | Optimistic locking with version fields | Manual version tracking error-prone, transactions are atomic and built-in               |
| Cloud Tasks  | setTimeout + in-memory state           | setTimeout doesn't persist across instances, Cloud Tasks is reliable                    |

**Installation:**

```bash
# Cloud Tasks (if not already installed)
npm install @google-cloud/tasks
```

**Note:** Cloud Functions already includes firebase-admin and @google-cloud/firestore, no additional installation needed for core batching.
</standard_stack>

<architecture_patterns>

## Architecture Patterns

### Recommended Project Structure

```
functions/
‚îú‚îÄ‚îÄ index.js                    # Main Cloud Functions exports
‚îú‚îÄ‚îÄ notifications/
‚îÇ   ‚îú‚îÄ‚îÄ sender.js              # Push notification delivery
‚îÇ   ‚îî‚îÄ‚îÄ batching.js            # NEW: Batching logic (Firestore-based)
‚îî‚îÄ‚îÄ tasks/
    ‚îî‚îÄ‚îÄ sendBatchedNotification.js  # NEW: Cloud Task handler for delayed sends
```

### Pattern 1: Firestore-Based Batching with Transactions

**What:** Use Firestore documents to track pending batches instead of in-memory state
**When to use:** All stateless serverless batching scenarios
**Example:**

```javascript
// Firestore collection: reactionBatches/{batchId}
// batchId format: `${photoId}_${reactorId}`

async function addReactionToBatch(photoId, reactorId, reactions) {
  const db = admin.firestore();
  const batchId = `${photoId}_${reactorId}`;
  const batchRef = db.collection('reactionBatches').doc(batchId);

  // Use transaction for atomic read-modify-write
  await db.runTransaction(async transaction => {
    const batchDoc = await transaction.get(batchRef);

    if (batchDoc.exists) {
      // Existing batch - merge reactions
      const existingData = batchDoc.data();
      const mergedReactions = { ...existingData.reactions };

      for (const [emoji, count] of Object.entries(reactions)) {
        mergedReactions[emoji] = (mergedReactions[emoji] || 0) + count;
      }

      transaction.update(batchRef, {
        reactions: mergedReactions,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });
    } else {
      // New batch - create with 30s expiration
      const expiresAt = new Date(Date.now() + 30000);

      transaction.set(batchRef, {
        photoId,
        reactorId,
        reactions,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        expiresAt,
        status: 'pending',
      });

      // Schedule Cloud Task to send notification after 30s
      await scheduleNotificationTask(batchId, 30);
    }
  });
}
```

### Pattern 2: Cloud Tasks for Delayed Execution

**What:** Use Cloud Tasks to schedule notification sends after batching window
**When to use:** When you need precise delayed execution (not Firestore TTL's 24-72h window)
**Example:**

```javascript
const { CloudTasksClient } = require('@google-cloud/tasks');
const client = new CloudTasksClient();

async function scheduleNotificationTask(batchId, delaySeconds) {
  const project = process.env.GCLOUD_PROJECT;
  const location = 'us-central1'; // Same region as Cloud Functions
  const queue = 'notification-batches';

  const parent = client.queuePath(project, location, queue);

  // Create task targeting Cloud Function HTTP endpoint
  const task = {
    httpRequest: {
      httpMethod: 'POST',
      url: `https://${location}-${project}.cloudfunctions.net/sendBatchedNotification`,
      headers: {
        'Content-Type': 'application/json',
      },
      body: Buffer.from(JSON.stringify({ batchId })).toString('base64'),
    },
    scheduleTime: {
      seconds: Math.floor(Date.now() / 1000) + delaySeconds,
    },
  };

  await client.createTask({ parent, task });
}
```

### Pattern 3: Idempotent Notification Sender

**What:** Ensure notification send function can safely retry without duplicates
**When to use:** All Cloud Functions that send notifications (critical for reliability)
**Example:**

```javascript
async function sendBatchedNotification(batchId) {
  const db = admin.firestore();
  const batchRef = db.collection('reactionBatches').doc(batchId);

  // Use transaction to check status and mark as processing
  const batchData = await db.runTransaction(async transaction => {
    const batchDoc = await transaction.get(batchRef);

    if (!batchDoc.exists) {
      logger.debug('Batch already processed or deleted:', batchId);
      return null; // Idempotent: already sent
    }

    const data = batchDoc.data();

    if (data.status === 'sent') {
      logger.debug('Batch already sent:', batchId);
      return null; // Idempotent: already sent
    }

    // Mark as processing to prevent concurrent sends
    transaction.update(batchRef, { status: 'processing' });
    return data;
  });

  if (!batchData) return; // Already processed

  try {
    // Send notification
    await sendPushNotification(/* ... */);

    // Mark as sent
    await batchRef.update({ status: 'sent', sentAt: admin.firestore.FieldValue.serverTimestamp() });
  } catch (error) {
    // Reset status on failure so retry can re-attempt
    await batchRef.update({ status: 'pending' });
    throw error;
  }
}
```

### Anti-Patterns to Avoid

- **In-memory state for batching:** Cloud Functions instances are stateless; memory doesn't persist
- **setTimeout without persistence:** Timers don't survive instance recycling
- **No idempotency checks:** Retries will send duplicate notifications
- **Manual version tracking:** Firestore transactions handle this automatically
- **Polling for expiration:** Use Cloud Tasks for push-based execution instead
  </architecture_patterns>

<dont_hand_roll>

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem                | Don't Build                       | Use Instead                      | Why                                                                               |
| ---------------------- | --------------------------------- | -------------------------------- | --------------------------------------------------------------------------------- |
| Distributed locking    | Custom lock files with timestamps | Firestore transactions           | Transactions are atomic, handle contention automatically, retry failed operations |
| Delayed task execution | setTimeout + persistence hacks    | Cloud Tasks                      | Cloud Tasks survives instance death, has retry logic, supports rate limiting      |
| Deduplication          | Manual tracking with Set/Map      | Transaction status checks        | Status field + transaction guarantees exactly-once processing                     |
| Time-window batching   | Custom in-memory timers           | Firestore document + Cloud Tasks | Firestore persists state, Cloud Tasks executes at exact time                      |
| Cleanup of old batches | Manual cron job scanning          | Firestore TTL policies           | TTL automatically deletes expired documents, zero maintenance                     |

**Key insight:** Serverless environments like Cloud Functions are stateless by design. Any batching solution that relies on in-memory state (variables, setTimeout, closures) will fail when instances scale, recycle, or run concurrently. Firestore provides durable state, transactions prevent race conditions, and Cloud Tasks handles scheduling. Fighting these tools leads to duplicate notifications, lost batches, and race conditions that are hard to reproduce and debug.
</dont_hand_roll>

<common_pitfalls>

## Common Pitfalls

### Pitfall 1: Transaction Contention with High-Frequency Writes

**What goes wrong:** If many reactions hit the same batch document rapidly, transactions fail with contention errors
**Why it happens:** Firestore transactions lock documents during read-modify-write; concurrent writes to the same document cause retries
**How to avoid:**

- Firestore client libraries automatically retry failed transactions
- Keep transaction logic minimal (read batch, update reactions, write)
- Avoid large reads inside transactions
- Consider that 30-second windows naturally limit contention (most reactions don't cluster that tightly)
  **Warning signs:** Cloud Functions logs show repeated "ABORTED" or "contention" errors

### Pitfall 2: Zombie Batches (Never Sent)

**What goes wrong:** Batch document created but Cloud Task never executes or fails silently
**Why it happens:** Task creation can fail, task execution can fail, or task queue might be paused
**How to avoid:**

- Add Firestore TTL policy to auto-delete batches after 1 hour (safety net)
- Include `status` field: 'pending' ‚Üí 'processing' ‚Üí 'sent' or 'failed'
- Monitor Cloud Tasks execution via Cloud Logging
- Implement idempotency so retries don't duplicate notifications
  **Warning signs:** reactionBatches collection accumulates old 'pending' documents

### Pitfall 3: Clock Drift and Timing Issues

**What goes wrong:** Batch expires slightly early or late, notifications arrive at unexpected times
**Why it happens:** Client clocks differ from server clocks, serverTimestamp() vs Date.now()
**How to avoid:**

- Always use `admin.firestore.FieldValue.serverTimestamp()` for `createdAt`/`updatedAt`
- Calculate `expiresAt` on server: `new Date(Date.now() + 30000)`
- Cloud Tasks uses server time for scheduling (no client drift)
- Don't trust client-provided timestamps
  **Warning signs:** Notifications send immediately or way too late

### Pitfall 4: Duplicate Notifications from Retries

**What goes wrong:** Cloud Function retries after partial success, sends duplicate notifications
**Why it happens:** Function times out, crashes, or returns error after sending notification but before marking batch as sent
**How to avoid:**

- Use transaction to atomically check status before sending
- Mark batch as 'processing' before sending, 'sent' after
- If send fails, reset to 'pending' so retry can re-attempt
- Check `status === 'sent'` and exit early (idempotency)
  **Warning signs:** Users report receiving 2-3 identical notifications for same reaction

### Pitfall 5: Firestore Document Size Limits

**What goes wrong:** Batch document exceeds 1MB size limit if too many reactions accumulate
**Why it happens:** Reaction batching accumulates reactions object which could theoretically grow large
**How to avoid:**

- 30-second window naturally limits batch size (unlikely to hit 1MB in 30s)
- Reactions object is small: `{ "üòÇ": 5, "‚ù§Ô∏è": 2 }` ~50 bytes per emoji
- Even 1000 reactions = ~50KB, well under 1MB limit
- If paranoid: add batch size check, split into new batch if approaching limit
  **Warning signs:** Firestore throws "Document size exceeds maximum" error (very unlikely)
  </common_pitfalls>

<code_examples>

## Code Examples

Verified patterns from official sources:

### Basic Transaction Pattern (Official Firebase Docs)

```javascript
// Source: https://firebase.google.com/docs/firestore/manage-data/transactions
const db = admin.firestore();

await db.runTransaction(async transaction => {
  const docRef = db.collection('reactionBatches').doc(batchId);
  const doc = await transaction.get(docRef);

  if (doc.exists) {
    // Update existing document
    const currentData = doc.data();
    transaction.update(docRef, {
      reactions: mergeReactions(currentData.reactions, newReactions),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });
  } else {
    // Create new document
    transaction.set(docRef, {
      reactions: newReactions,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      status: 'pending',
    });
  }
});
```

### Cloud Tasks Delayed Execution (Official Google Cloud Docs)

```javascript
// Source: https://firebase.google.com/docs/functions/task-functions
const { CloudTasksClient } = require('@google-cloud/tasks');
const client = new CloudTasksClient();

async function enqueueTask(functionUrl, payload, delaySeconds) {
  const project = process.env.GCLOUD_PROJECT;
  const location = 'us-central1';
  const queue = 'default';

  const parent = client.queuePath(project, location, queue);

  const task = {
    httpRequest: {
      httpMethod: 'POST',
      url: functionUrl,
      body: Buffer.from(JSON.stringify(payload)).toString('base64'),
    },
    scheduleTime: {
      seconds: Math.floor(Date.now() / 1000) + delaySeconds,
    },
  };

  const [response] = await client.createTask({ parent, task });
  return response.name;
}
```

### Idempotent Function Pattern (Firebase Best Practices)

```javascript
// Source: https://firebase.google.com/docs/functions/tips
// Functions should produce same result even if called multiple times

async function processNotification(batchId) {
  const batchRef = db.collection('reactionBatches').doc(batchId);

  // Check if already processed (idempotency)
  const batchDoc = await batchRef.get();
  if (!batchDoc.exists || batchDoc.data().status === 'sent') {
    logger.debug('Already processed:', batchId);
    return; // Safe to call multiple times
  }

  // Process...
  await sendNotification(/* ... */);

  // Mark as complete
  await batchRef.update({ status: 'sent' });
}
```

### Firestore TTL for Cleanup (Official Firebase Docs)

```javascript
// Source: https://firebase.google.com/docs/firestore/ttl
// Configure TTL policy via Firebase CLI or Console:
// Collection: reactionBatches
// TTL field: expiresAt
// Documents automatically deleted within 24-72 hours after expiresAt

// In document creation:
const expiresAt = new Date(Date.now() + 3600000); // 1 hour from now
await db.collection('reactionBatches').doc(batchId).set({
  // ... other fields
  expiresAt, // TTL field for automatic cleanup
});
```

</code_examples>

<sota_updates>

## State of the Art (2024-2025)

What's changed recently:

| Old Approach             | Current Approach                          | When Changed                | Impact                                                            |
| ------------------------ | ----------------------------------------- | --------------------------- | ----------------------------------------------------------------- |
| setTimeout for delays    | Cloud Tasks                               | Always recommended          | Cloud Tasks persist across instance recycling, setTimeout doesn't |
| Manual cleanup cron jobs | Firestore TTL policies                    | Dec 2022 (GA)               | TTL auto-deletes expired documents, zero maintenance              |
| Custom retry logic       | Built-in Cloud Functions retries          | Built-in                    | Automatic retry with exponential backoff, respect idempotency     |
| Pessimistic locking      | Optimistic transactions (mobile/web SDKs) | Default for Cloud Functions | Better for high-latency environments, automatic retries           |

**New tools/patterns to consider:**

- **Firestore TTL (GA since Dec 2022):** Set `expiresAt` field, documents auto-delete within 24-72 hours. Perfect for cleanup of old batches. Note: Too slow for 30-second batching window, but excellent for safety net cleanup.
- **Cloud Tasks max delay:** Can schedule tasks up to 30 days in future. For 30-second batching, this is more than sufficient.
- **preferRest option (firebase-admin):** Initialize Firestore with `{ preferRest: true }` for faster cold starts. Already used in this project (line 19 of functions/index.js).

**Deprecated/outdated:**

- **In-memory state for batching:** Never worked reliably in Cloud Functions, still see it in old tutorials
- **Manual version tracking for optimistic locking:** Firestore transactions handle this automatically
- **Firestore batched writes for reads:** Batched writes are write-only; use transactions if you need to read before writing
  </sota_updates>

<open_questions>

## Open Questions

Things that couldn't be fully resolved:

1. **Should we use Cloud Tasks or rely solely on Firestore listeners?**
   - What we know: Cloud Tasks gives precise 30-second delay; Firestore listener could react to document creation and wait 30s
   - What's unclear: Performance implications of thousands of active listeners vs task queue throughput
   - Recommendation: Use Cloud Tasks for precise execution timing. Firestore listeners would require in-memory setTimeout (back to original problem) or polling (inefficient).

2. **How to handle partial batch sends (notification sent but Firestore update fails)?**
   - What we know: Transaction marks as 'processing' before send, 'sent' after
   - What's unclear: If notification sends but update fails, retry will send duplicate
   - Recommendation: Accept this edge case (extremely rare) or store notification ID in FCM send result and check for duplicates in app. For MVP, rely on transaction atomicity for status updates.

3. **Should old batches be cleaned up immediately or kept for debugging?**
   - What we know: Firestore TTL can auto-delete after 1 hour (safety net)
   - What's unclear: Value of keeping 'sent' batches for debugging vs storage cost
   - Recommendation: Keep for 7 days via TTL for debugging, then auto-delete. Storage cost is negligible for notification metadata.
     </open_questions>

<sources>
## Sources

### Primary (HIGH confidence)

- [Firebase Cloud Functions Tips & Tricks](https://firebase.google.com/docs/functions/tips) - Idempotency, stateless design, retry patterns
- [Firestore Transactions and Batched Writes](https://firebase.google.com/docs/firestore/manage-data/transactions) - Transaction patterns, atomic operations
- [Cloud Tasks for Firebase Functions](https://firebase.google.com/docs/functions/task-functions) - Delayed execution, task scheduling
- [Firestore TTL Policies](https://firebase.google.com/docs/firestore/ttl) - Automatic cleanup, TTL configuration
- [Transaction Contention Best Practices](https://firebase.google.com/docs/firestore/transaction-data-contention) - Handling contention, optimization

### Secondary (MEDIUM confidence)

- [Batch Processing with Firebase Cloud Functions (Medium)](https://medium.com/@michael.kimpton/batch-processing-with-firebase-cloud-functions-aa11640cc9ac) - Verified recursive batching pattern against official docs
- [Best Practices for FCM at Scale](https://firebase.google.com/docs/cloud-messaging/scale-fcm) - Verified batching up to 500 tokens, rate limiting
- [Race Conditions in Firestore (Medium)](https://medium.com/quintoandar-tech-blog/race-conditions-in-firestore-how-to-solve-it-5d6ff9e69ba7) - Verified transaction solutions against official docs

### Tertiary (LOW confidence - needs validation)

- None - all core findings verified with official Firebase documentation
  </sources>

<metadata>
## Metadata

**Research scope:**

- Core technology: Firebase Cloud Functions, Firestore transactions
- Ecosystem: Cloud Tasks, Firebase Admin SDK, Firestore TTL
- Patterns: Stateless batching, time-window management, idempotency
- Pitfalls: Transaction contention, zombie batches, duplicate notifications

**Confidence breakdown:**

- Standard stack: HIGH - All official Firebase/Google Cloud tools
- Architecture: HIGH - Patterns from official docs and verified examples
- Pitfalls: HIGH - Documented in official best practices and GitHub issues
- Code examples: HIGH - From official Firebase documentation

**Research date:** 2026-02-13
**Valid until:** 2026-03-13 (30 days - Firebase ecosystem is stable)

**Current implementation analysis:**

- Existing code uses in-memory `pendingReactions` object (line 22, functions/index.js)
- Current debounce: 10 seconds (`REACTION_DEBOUNCE_MS = 10000`)
- Batching logic: Lines 888-910 (merge reactions, extend timeout)
- This pattern CANNOT work reliably in stateless Cloud Functions
- Each photo update can trigger different instance with separate memory
  </metadata>

---

_Phase: 52.1-reaction-notif-batching_
_Research completed: 2026-02-13_
_Ready for planning: yes_
