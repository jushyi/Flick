---
phase: 04-snap-streaks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/index.js
  - functions/__tests__/triggers/streakFunctions.test.js
  - firestore.rules
autonomous: true
requirements:
  - STRK-01
  - STRK-02
  - STRK-05
  - STRK-06
  - STRK-07

must_haves:
  truths:
    - 'When both users exchange snaps within the expiry window, the streak dayCount increments'
    - 'After 3 consecutive days of mutual snaps, the streak is active (dayCount >= 3)'
    - 'If the expiry window passes without mutual snaps, the streak resets to 0'
    - 'Warning flag is set 4 hours before expiry with push notification sent to both users'
    - 'All streak writes happen via Cloud Functions admin SDK, never client-side'
    - 'Simultaneous snap sends do not lose data due to Firestore transaction usage'
  artifacts:
    - path: 'functions/index.js'
      provides: 'updateStreakOnSnap logic in onNewMessage + processStreakExpiry scheduled function'
      contains: 'updateStreakOnSnap'
    - path: 'functions/__tests__/triggers/streakFunctions.test.js'
      provides: 'Unit tests for streak Cloud Functions'
      min_lines: 100
    - path: 'firestore.rules'
      provides: 'Streak collection security rules (read-only for participants)'
      contains: 'match /streaks/'
  key_links:
    - from: 'functions/index.js (onNewMessage)'
      to: 'functions/index.js (updateStreakOnSnap)'
      via: "type === 'snap' check triggers streak update"
      pattern: 'messageType.*===.*snap.*updateStreakOnSnap'
    - from: 'functions/index.js (processStreakExpiry)'
      to: 'functions/index.js (sendPushNotification)'
      via: 'Warning state triggers push notification to both users'
      pattern: 'sendPushNotification'
---

<objective>
Build the server-side streak engine: extend onNewMessage to track mutual snap exchanges and manage streak lifecycle, add processStreakExpiry scheduled function for expiry/warning processing, and lock down Firestore security rules to enforce server-authoritative design.

Purpose: This is the foundation of the streak system. All streak state transitions happen server-side via Cloud Functions. The client will be strictly read-only (enforced by Firestore rules). This plan delivers the complete backend logic that Plans 02-04 consume.

Output: Extended functions/index.js with streak logic, streak Cloud Function tests, Firestore rules for streaks collection.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-snap-streaks/04-CONTEXT.md
@.planning/phases/04-snap-streaks/04-RESEARCH.md
@functions/index.js
@firestore.rules
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement updateStreakOnSnap and processStreakExpiry Cloud Functions</name>
  <files>functions/index.js, firestore.rules</files>
  <action>
**1. Add streak constants and helper at top of functions/index.js (near existing constants):**

```javascript
// Streak expiry windows (tiered progressive leniency per user decision)
const STREAK_EXPIRY_TIERS = {
  base: 36 * 60 * 60 * 1000, // 36 hours (day 0-9)
  tier10: 48 * 60 * 60 * 1000, // 48 hours (day 10-49)
  tier50: 72 * 60 * 60 * 1000, // 72 hours (day 50+)
};
const STREAK_WARNING_HOURS = 4; // Warning sent 4h before expiry
const DAY_MS = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

const STREAK_WARNING_TEMPLATES = [
  'Your streak with {name} is about to expire!',
  "Don't let your streak with {name} die!",
  'Quick — snap {name} before your streak ends!',
];

function getExpiryWindowMs(dayCount) {
  if (dayCount >= 50) return STREAK_EXPIRY_TIERS.tier50;
  if (dayCount >= 10) return STREAK_EXPIRY_TIERS.tier10;
  return STREAK_EXPIRY_TIERS.base;
}
```

**2. Add `updateStreakOnSnap` function (module-level helper, NOT exported):**

This function is called from inside `onNewMessage` when `messageType === 'snap'`.

Key logic:

- Generate streak ID using same deterministic pattern as conversations: `[lowerUserId]_[higherUserId]`
- Use a Firestore **transaction** to atomically read-then-write the streak document (prevents race conditions on simultaneous snaps per Pitfall 2 from research)
- Inside transaction:
  - Read current streak document (may not exist yet)
  - Update `lastSnapBy[senderId]` to current server timestamp (`admin.firestore.Timestamp.now()`)
  - Check if mutual snaps now exist (both users have snapped)
  - If mutual:
    - Check if >= 24h since `lastMutualAt` (or `lastMutualAt` is null for first mutual exchange)
    - If yes: increment `dayCount` by 1
    - Update `lastMutualAt` to now
    - Calculate new `expiresAt` = now + getExpiryWindowMs(dayCount)
    - Calculate `warningAt` = expiresAt - 4 hours (for processStreakExpiry to query efficiently per Research Open Question 2)
    - Reset `warning` to false (new mutual exchange clears any active warning)
    - Reset `warningSentAt` to null
    - Clear both users' `lastSnapBy` entries (reset for next day's exchange tracking)
  - If NOT mutual (only one side has snapped): just update `lastSnapBy`, leave everything else
  - Set `updatedAt` to now
- If streak document does not exist, create it with initial values: `participants: [sorted], dayCount: 0, lastSnapBy: {senderId: now}, lastMutualAt: null, streakStartedAt: null, expiresAt: null, warningAt: null, warning: false, warningSentAt: null, updatedAt: now`
- When dayCount transitions from 0 to 1 (first mutual exchange), set `streakStartedAt` to now

**Important edge case:** When the mutual exchange completes and dayCount increments, clear BOTH `lastSnapBy` entries to null. This ensures the next day requires fresh snaps from both sides. The "1 snap from each side is enough" rule means we only check existence, not count.

**3. Hook updateStreakOnSnap into onNewMessage:**

Inside the existing `onNewMessage` function, after the conversation metadata update block (after `batch.commit()`) and before the notification sending block, add:

```javascript
// Update streak data for snap messages
if (messageType === 'snap') {
  try {
    await updateStreakOnSnap(conversationId, senderId, recipientId);
  } catch (streakError) {
    // Best-effort: log but don't fail the message trigger
    logger.error('onNewMessage: Streak update failed', {
      conversationId,
      error: streakError.message,
    });
  }
}
```

Use best-effort pattern (log but don't throw) matching the existing onSnapViewed pattern — streak failure should not break message delivery.

**4. Add `processStreakExpiry` scheduled Cloud Function:**

Pattern: mirrors `processDarkroomReveals` exactly (pubsub.schedule).

```javascript
exports.processStreakExpiry = functions
  .runWith({ memory: '256MB', timeoutSeconds: 120 })
  .pubsub.schedule('every 30 minutes')
  .onRun(async context => {
    const now = admin.firestore.Timestamp.now();
    const nowMs = now.toMillis();

    // 1. Process warnings: warningAt <= now AND warning == false
    const warningSnapshot = await db
      .collection('streaks')
      .where('warningAt', '<=', now)
      .where('warning', '==', false)
      .limit(200)
      .get();

    // 2. Process expired: expiresAt <= now AND expiresAt != null
    const expiredSnapshot = await db
      .collection('streaks')
      .where('expiresAt', '<=', now)
      .limit(200)
      .get();

    // Process warnings
    const warningResults = await Promise.allSettled(
      warningSnapshot.docs
        .filter(doc => !doc.data().expiresAt || doc.data().expiresAt.toMillis() > nowMs) // Not already expired
        .map(async streakDoc => {
          const streak = streakDoc.data();
          // Set warning flag
          await streakDoc.ref.update({
            warning: true,
            warningSentAt: now,
            updatedAt: now,
          });
          // Send push notification to BOTH participants
          for (const userId of streak.participants) {
            const otherUserId = streak.participants.find(p => p !== userId);
            const otherUser = await db.collection('users').doc(otherUserId).get();
            const otherName = otherUser.exists
              ? otherUser.data().displayName || otherUser.data().username
              : 'your friend';

            const user = await db.collection('users').doc(userId).get();
            if (!user.exists) continue;
            const userData = user.data();
            const fcmToken = userData.fcmToken;
            if (!fcmToken) continue;

            // Check notification preferences (streakWarnings toggle)
            const prefs = userData.notificationPreferences || {};
            if (prefs.enabled === false || prefs.streakWarnings === false) continue;

            const template = getRandomTemplate(STREAK_WARNING_TEMPLATES);
            const body = template.replace('{name}', otherName);

            await sendPushNotification(fcmToken, {
              title: 'Flick',
              body,
              data: {
                type: 'streak_warning',
                conversationId: streakDoc.id,
                userId: otherUserId,
              },
            });
          }
        })
    );

    // Process expired streaks — reset to inactive
    const expiryResults = await Promise.allSettled(
      expiredSnapshot.docs
        .filter(doc => doc.data().expiresAt && doc.data().expiresAt.toMillis() <= nowMs)
        .map(async streakDoc => {
          await streakDoc.ref.update({
            dayCount: 0,
            lastMutualAt: null,
            streakStartedAt: null,
            expiresAt: null,
            warningAt: null,
            warning: false,
            warningSentAt: null,
            lastSnapBy: {
              [streakDoc.data().participants[0]]: null,
              [streakDoc.data().participants[1]]: null,
            },
            updatedAt: now,
          });
        })
    );

    const warningCount = warningResults.filter(r => r.status === 'fulfilled').length;
    const expiryCount = expiryResults.filter(r => r.status === 'fulfilled').length;
    logger.info('processStreakExpiry: Complete', { warningCount, expiryCount });
    return null;
  });
```

**5. Add Firestore security rules for streaks collection:**

In `firestore.rules`, add a new top-level match block for streaks:

```
match /streaks/{streakId} {
  // Read: only participants can read their own streak
  allow read: if request.auth != null
    && request.auth.uid in resource.data.participants;
  // Write: denied — all writes via Cloud Functions (admin SDK)
  allow write: if false;
}
```

This enforces STRK-07: all streak calculations are server-authoritative. Client can only read.
</action>
<verify>
<automated>cd "C:/Users/maser/Lapse Clone/functions" && node -e "const f = require('./index.js'); console.log('processStreakExpiry:', typeof f.processStreakExpiry); console.log('onNewMessage:', typeof f.onNewMessage);"</automated>
<manual>Verify firestore.rules contains streaks collection match block with write: if false</manual>
</verify>
<done>updateStreakOnSnap function exists and is called from onNewMessage for snap messages. processStreakExpiry scheduled function handles warnings and expiry. Firestore rules deny client writes to streaks collection. Streak document schema includes all fields from research (participants, dayCount, lastSnapBy, lastMutualAt, streakStartedAt, expiresAt, warningAt, warning, warningSentAt, updatedAt).</done>
</task>

<task type="auto">
  <name>Task 2: Add streak Cloud Function tests</name>
  <files>functions/__tests__/triggers/streakFunctions.test.js</files>
  <action>
Create `functions/__tests__/triggers/streakFunctions.test.js` with comprehensive tests for streak logic.

**Follow the existing functions test pattern** from `functions/__tests__/snapFunctions.test.js`:

- Mock firebase-admin, firebase-functions, logger at module scope
- Define mock functions outside jest.mock blocks
- Use `require` after all mocks
- `clearAllMocks` in beforeEach

**Test suite structure:**

```
describe('Streak Functions')
  describe('updateStreakOnSnap (via onNewMessage)')
    - creates new streak document when none exists on first snap
    - updates lastSnapBy for sender without incrementing dayCount (one-sided snap)
    - increments dayCount when mutual snaps complete (both users have snapped)
    - does NOT increment dayCount if less than 24h since lastMutualAt
    - DOES increment dayCount if >= 24h since lastMutualAt
    - clears lastSnapBy for both users after mutual exchange completes
    - sets streakStartedAt on first mutual exchange (dayCount 0->1)
    - calculates correct expiresAt using base tier (36h) for dayCount < 10
    - calculates correct expiresAt using tier10 (48h) for dayCount 10-49
    - calculates correct expiresAt using tier50 (72h) for dayCount >= 50
    - resets warning and warningSentAt on new mutual exchange
    - uses Firestore transaction for atomicity (race condition safety)
    - best-effort: streak error does not fail onNewMessage

  describe('processStreakExpiry')
    - sets warning=true for streaks where warningAt <= now and warning is false
    - sends push notification to both participants on warning
    - skips notification when user has streakWarnings preference disabled
    - skips already-expired streaks when processing warnings
    - resets expired streaks: dayCount=0, expiresAt=null, lastMutualAt=null
    - does not double-send warnings (warningSentAt guard)
    - handles empty query results gracefully
```

Each test should:

- Set up mock Firestore data (streak documents with specific field values)
- Trigger the function
- Assert on Firestore writes (update/set calls) and push notification sends
- Verify timestamps use admin.firestore.Timestamp.now() not Date

**Mock setup pattern for onNewMessage:**
The existing onNewMessage tests show how to simulate message creation triggers. For streak tests, create snap message data: `{ type: 'snap', senderId: 'user1', snapStoragePath: 'snap-photos/...', createdAt: Timestamp }`. The onNewMessage trigger receives `change.after.data()`.

Since functions/index.js is large (3274 lines), reference the existing test patterns in `functions/__tests__/snapFunctions.test.js` and `functions/__tests__/triggers/notifications.test.js` for mock setup.

**Important:** The `updateStreakOnSnap` function is a module-level helper (not exported). Test it indirectly by calling `onNewMessage` with snap message data and asserting the streak document was created/updated. If direct testing is needed, extract `updateStreakOnSnap` to a separate module or test via the exported `onNewMessage` function.
</action>
<verify>
<automated>cd "C:/Users/maser/Lapse Clone/functions" && npx jest --testPathPattern=streakFunctions --forceExit --detectOpenHandles 2>&1 | tail -20</automated>
</verify>
<done>All streak Cloud Function tests pass. Tests cover: new streak creation, one-sided snap, mutual snap dayCount increment, 24h gate, tiered expiry windows (36h/48h/72h), warning flag setting, push notification sending with preference check, streak reset on expiry, race condition safety via transactions, and best-effort error handling.</done>
</task>

</tasks>

<verification>
- `cd functions && npx jest --testPathPattern=streakFunctions --forceExit` passes all tests
- `node -e "const f = require('./functions/index.js'); console.log(typeof f.processStreakExpiry, typeof f.onNewMessage);"` outputs "function function"
- `firestore.rules` contains `match /streaks/{streakId}` with `allow write: if false`
- Streak document schema matches research specification
- No client-side streak writes possible (Firestore rules enforce)
</verification>

<success_criteria>

- Server-side streak engine fully implemented: mutual snap tracking, dayCount increment, tiered expiry, warning state, push notifications
- processStreakExpiry scheduled function processes warnings and expired streaks
- All streak writes via admin SDK only (STRK-07)
- Comprehensive test suite validates all streak state transitions
- Firestore rules deny client writes to streaks collection
  </success_criteria>

<output>
After completion, create `.planning/phases/04-snap-streaks/04-01-SUMMARY.md`
</output>
