---
phase: 09-pinned-snaps-ios
plan: 04
type: execute
wave: 3
depends_on:
  - 09-03
files_modified:
  - App.js
  - src/components/SnapViewer.js
  - functions/index.js
  - __tests__/services/snapService.test.js
autonomous: true
requirements:
  - PINI-03
  - PINI-04

must_haves:
  truths:
    - "Recipient sees a Live Activity on lock screen when a pinned snap notification arrives"
    - "Tapping the Live Activity opens the app to the correct conversation"
    - "Live Activity disappears from lock screen after recipient views the snap"
    - "Cloud Function sends pinned snap data in notification payload"
  artifacts:
    - path: "App.js"
      provides: "Notification handler that starts Live Activity for pinned snap notifications on iOS"
    - path: "src/components/SnapViewer.js"
      provides: "Ends Live Activity when snap is viewed (markSnapViewed success)"
    - path: "functions/index.js"
      provides: "onNewMessage includes pinned fields in snap push notification data, onSnapViewed ends Live Activity"
    - path: "__tests__/services/snapService.test.js"
      provides: "Extended tests for pinned flag in message data and view-triggered cleanup"
  key_links:
    - from: "App.js"
      to: "src/services/liveActivityService.js"
      via: "startPinnedSnapActivity on notification receipt"
      pattern: "startPinnedSnapActivity"
    - from: "src/components/SnapViewer.js"
      to: "src/services/liveActivityService.js"
      via: "endPinnedSnapActivity after markSnapViewed"
      pattern: "endPinnedSnapActivity"
    - from: "functions/index.js"
      to: "Expo push notification"
      via: "data payload with pinned fields"
      pattern: "pinned.*true"
    - from: "App.js"
      to: "src/services/liveActivityService.js"
      via: "notification response handler triggers Live Activity start"
      pattern: "notifData\\.pinned"
---

<objective>
Wire the recipient-side Live Activity lifecycle: start on notification receipt, deep link on tap, dismiss on snap view.

Purpose: PINI-03 and PINI-04 require the Live Activity to appear when a pinned snap arrives and disappear when the recipient views it. This plan connects the Cloud Function notification payload, App.js notification handler, and SnapViewer view event to the liveActivityService.

Output: Complete recipient-side flow — pinned snap notification triggers Live Activity creation, tapping opens conversation, viewing snap dismisses the Live Activity.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-pinned-snaps-ios/09-CONTEXT.md
@.planning/phases/09-pinned-snaps-ios/09-RESEARCH.md
@.planning/phases/09-pinned-snaps-ios/09-03-SUMMARY.md
@App.js
@src/components/SnapViewer.js
@functions/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Cloud Function onNewMessage to include pinned fields in snap notification payload</name>
  <files>
    functions/index.js
  </files>
  <action>
    1. In `functions/index.js`, find the `onNewMessage` Cloud Function where it handles `type === 'snap'` messages.

    2. When the snap message has `pinned: true`, include additional data fields in the push notification payload sent to the recipient:
       - `pinned: 'true'` (string, push notification data values must be strings)
       - `pinnedActivityId: messageData.pinnedActivityId`
       - `pinnedThumbnailUrl: messageData.pinnedThumbnailUrl`
       - `caption: messageData.caption || ''`
       - `senderName: senderProfile.displayName` (already available in the function context)
       - `conversationId: conversationId` (already available in context)

    3. The existing notification data fields (type, senderId, etc.) should remain unchanged. Only ADD the pinned fields.

    4. In the notification title/body templates for snap messages, when pinned is true, add a subtle indicator like "pinned a snap to your screen" (or keep the existing randomized template — the Live Activity itself is the key UX, not the notification wording).

    5. **Do NOT modify the `onSnapViewed` function** for Live Activity dismissal. The client-side dismissal (SnapViewer calling endPinnedSnapActivity) is sufficient. Server-side dismissal via ActivityKit push tokens adds complexity for v1 — defer to v2 if needed.

    IMPORTANT: Do not change the notification structure for non-pinned snaps. Only add extra data fields when `pinned === true`.
  </action>
  <verify>
    <automated>cd functions && node -e "const idx = require('./index'); console.log('Functions loaded successfully');" 2>&1 || echo "Check function syntax"</automated>
    <manual>Review onNewMessage snap handler — pinned fields added conditionally to notification data. Non-pinned snaps unchanged.</manual>
  </verify>
  <done>onNewMessage Cloud Function includes pinned, pinnedActivityId, pinnedThumbnailUrl, caption, senderName, conversationId in notification data when snap message has pinned: true. Non-pinned snaps are unaffected.</done>
</task>

<task type="auto">
  <name>Task 2: Wire recipient notification handler (App.js) and SnapViewer dismissal</name>
  <files>
    App.js
    src/components/SnapViewer.js
    __tests__/services/snapService.test.js
  </files>
  <action>
    1. Modify `App.js` — notification received handler (the handler that fires when a notification arrives while the app is running or in background):
       - When a notification arrives with `data.type === 'snap'` and `data.pinned === 'true'` and `Platform.OS === 'ios'`:
         a. Import `startPinnedSnapActivity` from `./src/services/liveActivityService`
         b. Download the thumbnail from `data.pinnedThumbnailUrl` to a local temp file using `expo-file-system` `downloadAsync`
         c. Call `startPinnedSnapActivity`:
            ```javascript
            await startPinnedSnapActivity({
              activityId: data.pinnedActivityId,
              senderName: data.senderName,
              caption: data.caption || null,
              conversationId: data.conversationId,
              friendId: data.senderId,
              thumbnailUri: localThumbUri,
            });
            ```
         d. Wrap in try/catch — Live Activity failure should NOT block the notification from working normally
         e. Log success/failure via logger
       - IMPORTANT: This should happen in the notification received listener (not the response listener). The Live Activity should appear when the notification arrives, not when the user taps it. Tapping the Live Activity uses the deep link URL set during `startActivity`.

    2. Modify `src/components/SnapViewer.js`:
       - After `markSnapViewed` succeeds (when the snap is opened/viewed by recipient):
         - Check if the snap message has `pinned === true` (the message object should include this field from Firestore)
         - If pinned and `Platform.OS === 'ios'`:
           ```javascript
           import { endPinnedSnapActivity } from '../services/liveActivityService';
           // After markSnapViewed success:
           if (message.pinned && Platform.OS === 'ios') {
             endPinnedSnapActivity(message.id || message.pinnedActivityId);
           }
           ```
         - Wrap in try/catch — Live Activity end failure should NOT block the snap viewing flow
         - Log via logger

    3. Extend `__tests__/services/snapService.test.js`:
       - Add test cases for the pinned flag:
         a. `uploadAndSendSnap` with `{ pinToScreen: true }` includes `pinned: true`, `pinnedActivityId`, `pinnedThumbnailUrl` in message data
         b. `uploadAndSendSnap` with `{ pinToScreen: false }` includes `pinned: false` and no pinnedActivityId/pinnedThumbnailUrl
         c. `uploadAndSendSnap` without options defaults to `pinned: false`
         d. Thumbnail is uploaded to `snap-thumbnails/` path when pinToScreen is true
         e. Thumbnail is NOT uploaded when pinToScreen is false
       - Mock `ImageManipulator` for thumbnail generation
       - Mock Firebase Storage for thumbnail upload and getDownloadURL

    NOTE: `notificationService.js` does NOT need modification. The Live Activity's `widgetURL` handles tap-to-open via the app's existing URL scheme (`lapse://messages/{conversationId}`), and the existing deep linking config in AppNavigator processes it. The snap notification tap handler continues to work as-is since it only reads `type` and `senderId`.

    IMPORTANT: Live Activity operations are best-effort. They must NEVER block or fail the snap send/view flow. Always wrap in try/catch with logging.
  </action>
  <verify>
    <automated>npx jest __tests__/services/snapService.test.js --no-coverage -x</automated>
    <manual>Review App.js notification handler for correct Platform guard and try/catch. Review SnapViewer for endPinnedSnapActivity call after markSnapViewed. Verify no Android crash paths.</manual>
  </verify>
  <done>App.js starts Live Activity on pinned snap notification receipt (iOS only). SnapViewer ends Live Activity when snap is viewed. Extended snapService tests cover pinned flag in message data. All operations are best-effort with try/catch.</done>
</task>

</tasks>

<verification>
1. `npx jest __tests__/services/snapService.test.js --no-coverage` passes with new pinned flag tests
2. App.js notification handler has Platform guard for iOS
3. App.js downloads thumbnail before starting Live Activity
4. SnapViewer calls endPinnedSnapActivity after markSnapViewed when message.pinned is true
5. Cloud Function includes pinned fields in notification data for pinned snaps only
6. All Live Activity operations wrapped in try/catch (best-effort)
7. Non-pinned snaps are completely unaffected in all code paths
8. `npm run lint` passes on all modified files
</verification>

<success_criteria>
- Cloud Function sends pinned snap data in notification payload
- Recipient's App.js starts Live Activity on notification receipt (iOS only)
- Live Activity deep link opens correct conversation via existing URL scheme
- SnapViewer dismisses Live Activity when snap is viewed
- All operations are best-effort (no blocking on Live Activity failures)
- Existing snap flow unchanged for non-pinned snaps
</success_criteria>

<output>
After completion, create `.planning/phases/09-pinned-snaps-ios/09-04-SUMMARY.md`
</output>
