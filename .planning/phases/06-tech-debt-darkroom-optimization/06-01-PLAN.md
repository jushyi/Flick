---
phase: 06-tech-debt-darkroom-optimization
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - __tests__/services/darkroomService.test.js
autonomous: true
requirements:
  - DARK-01
  - DARK-02

must_haves:
  truths:
    - 'isDarkroomReadyToReveal skips Firestore when cache is fresh and nextRevealAt is in the future'
    - 'isDarkroomReadyToReveal calls Firestore when cache is stale (older than 5 minutes)'
    - 'isDarkroomReadyToReveal calls Firestore when cached nextRevealAt has elapsed'
    - 'clearRevealCache resets the cache so the next call fetches from Firestore'
  artifacts:
    - path: '__tests__/services/darkroomService.test.js'
      provides: 'New describe blocks for cache hit/miss/stale/clear behavior'
      contains: 'clearRevealCache'
  key_links:
    - from: '__tests__/services/darkroomService.test.js'
      to: 'src/services/firebase/darkroomService.js'
      via: 'require after mocks'
      pattern: 'clearRevealCache'
---

<objective>
Write failing tests for the darkroom reveal cache before implementation exists. This is the RED phase of the TDD cycle for DARK-01 and DARK-02.

Purpose: Capture the cache contract in tests so the implementation in Plan 02 has a clear spec to satisfy. Tests will fail until the cache and clearRevealCache export are added to darkroomService.js.

Output: Appended test cases in **tests**/services/darkroomService.test.js covering cache hit, cache miss (stale), cache expiry (nextRevealAt elapsed), and cache invalidation via clearRevealCache.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/06-tech-debt-darkroom-optimization/06-CONTEXT.md
@.planning/phases/06-tech-debt-darkroom-optimization/06-RESEARCH.md
@__tests__/services/darkroomService.test.js
@src/services/firebase/darkroomService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Append cache behavior tests to darkroomService.test.js</name>
  <files>__tests__/services/darkroomService.test.js</files>
  <action>
Append a new top-level describe block `'isDarkroomReadyToReveal — cache behavior'` and a separate `'clearRevealCache'` describe block to the EXISTING test file. Do NOT modify existing tests.

CRITICAL setup notes:

1. The existing mock at the top of the file mocks `@react-native-firebase/firestore` — `mockGetDoc` is already defined.
2. The existing `mockCurrentTime = 1000000` (seconds) is used for Timestamp.now(). The cache uses `Date.now()` in milliseconds, so account for the unit difference.
3. The existing `createMockTimestamp(seconds)` helper returns `{ seconds, toDate: () => new Date(seconds * 1000) }` — it does NOT have a `toMillis()` method. The new isDarkroomReadyToReveal implementation will use `toMillis()` on the cached timestamp, so you need to extend `createMockTimestamp` to also expose `toMillis: () => seconds * 1000`. UPDATE the existing `createMockTimestamp` helper — do not replace it, just add the `toMillis` method.
4. Import `clearRevealCache` by adding it to the existing `require()` at the bottom of the mock setup block:

   ```javascript
   const {
     getDarkroom,
     isDarkroomReadyToReveal,
     scheduleNextReveal,
     ensureDarkroomInitialized,
     clearRevealCache, // ← add this
   } = require('../../src/services/firebase/darkroomService');
   ```

5. The module-level cache in darkroomService.js persists between tests because `require` caches the module. Call `clearRevealCache()` in `beforeEach` to reset cache state between tests.

Cache logic to test (per RESEARCH.md):

- Cache hit: `_revealCache.nextRevealAt !== null` AND `cachedAt` is < 5 minutes old AND `nextRevealAt.toMillis() > Date.now()` → return false WITHOUT calling Firestore
- Cache miss (first call): no cache → call Firestore → populate cache
- Cache stale (> 5 min old): cache exists but `Date.now() - cachedAt >= 5*60*1000` → re-fetch from Firestore
- Cached time elapsed: cache fresh but `nextRevealAt.toMillis() <= Date.now()` → re-fetch from Firestore (may be ready)

Use `jest.spyOn(Date, 'now')` to control `Date.now()` in tests. Restore with `jest.restoreAllMocks()` in afterEach or use mockImplementation.

Write these specific test cases in the new describe block:

```javascript
describe('isDarkroomReadyToReveal — cache behavior', () => {
  beforeEach(() => {
    clearRevealCache(); // Reset module-level cache between tests
  });

  it('should call Firestore on first invocation (cache miss)', async () => {
    const futureSeconds = mockCurrentTime + 300; // 5 minutes from now
    mockGetDoc.mockResolvedValueOnce({
      exists: () => true,
      data: () => ({
        userId: 'user-cache',
        nextRevealAt: createMockTimestamp(futureSeconds),
      }),
    });

    const result = await isDarkroomReadyToReveal('user-cache');

    expect(mockGetDoc).toHaveBeenCalledTimes(1);
    expect(result).toBe(false); // nextRevealAt is in the future
  });

  it('should skip Firestore on second call when cache is fresh and nextRevealAt is in the future', async () => {
    const nowMs = 1000000 * 1000; // match mockCurrentTime in ms
    jest.spyOn(Date, 'now').mockReturnValue(nowMs);

    const futureSeconds = mockCurrentTime + 300;
    mockGetDoc.mockResolvedValueOnce({
      exists: () => true,
      data: () => ({
        userId: 'user-cache',
        nextRevealAt: createMockTimestamp(futureSeconds),
      }),
    });

    // First call — populates cache
    await isDarkroomReadyToReveal('user-cache');
    mockGetDoc.mockClear();

    // Second call — should hit cache, not Firestore
    const result = await isDarkroomReadyToReveal('user-cache');

    expect(mockGetDoc).not.toHaveBeenCalled();
    expect(result).toBe(false);

    jest.restoreAllMocks();
  });

  it('should re-fetch from Firestore when cache is older than 5 minutes', async () => {
    const nowMs = 1000000 * 1000;
    jest
      .spyOn(Date, 'now')
      .mockReturnValueOnce(nowMs) // first call — cache write
      .mockReturnValueOnce(nowMs + 6 * 60 * 1000) // second call — 6 min later (stale)
      .mockReturnValue(nowMs + 6 * 60 * 1000);

    const futureSeconds = mockCurrentTime + 600;
    mockGetDoc
      .mockResolvedValueOnce({
        exists: () => true,
        data: () => ({ userId: 'user-cache', nextRevealAt: createMockTimestamp(futureSeconds) }),
      })
      .mockResolvedValueOnce({
        exists: () => true,
        data: () => ({ userId: 'user-cache', nextRevealAt: createMockTimestamp(futureSeconds) }),
      });

    // First call — populates cache
    await isDarkroomReadyToReveal('user-cache');
    // Second call — cache stale, must re-fetch
    await isDarkroomReadyToReveal('user-cache');

    expect(mockGetDoc).toHaveBeenCalledTimes(2);

    jest.restoreAllMocks();
  });

  it('should re-fetch from Firestore when cached nextRevealAt has elapsed', async () => {
    const nowMs = 1000000 * 1000;
    // First call: nextRevealAt 30 seconds in the future, cache written
    const soonSeconds = mockCurrentTime + 30;
    mockGetDoc
      .mockResolvedValueOnce({
        exists: () => true,
        data: () => ({ userId: 'user-cache', nextRevealAt: createMockTimestamp(soonSeconds) }),
      })
      .mockResolvedValueOnce({
        exists: () => true,
        data: () => ({ userId: 'user-cache', nextRevealAt: createMockTimestamp(soonSeconds - 60) }),
      });

    jest
      .spyOn(Date, 'now')
      .mockReturnValueOnce(nowMs) // first call — write cache with soonSeconds
      .mockReturnValue(nowMs + 60 * 1000); // second call — 1 min later, nextRevealAt has elapsed

    // First call — populates cache, returns false (not ready yet)
    await isDarkroomReadyToReveal('user-cache');
    mockGetDoc.mockClear();

    // Second call — cached nextRevealAt has elapsed, must re-fetch
    await isDarkroomReadyToReveal('user-cache');

    expect(mockGetDoc).toHaveBeenCalledTimes(1);

    jest.restoreAllMocks();
  });
});

describe('clearRevealCache', () => {
  it('should cause the next isDarkroomReadyToReveal call to fetch from Firestore', async () => {
    const nowMs = 1000000 * 1000;
    jest.spyOn(Date, 'now').mockReturnValue(nowMs);

    const futureSeconds = mockCurrentTime + 300;
    mockGetDoc
      .mockResolvedValueOnce({
        exists: () => true,
        data: () => ({ userId: 'user-cache', nextRevealAt: createMockTimestamp(futureSeconds) }),
      })
      .mockResolvedValueOnce({
        exists: () => true,
        data: () => ({ userId: 'user-cache', nextRevealAt: createMockTimestamp(futureSeconds) }),
      });

    // First call — populates cache
    await isDarkroomReadyToReveal('user-cache');
    // Clear cache
    clearRevealCache();
    mockGetDoc.mockClear();

    // Next call must fetch from Firestore (cache was cleared)
    await isDarkroomReadyToReveal('user-cache');

    expect(mockGetDoc).toHaveBeenCalledTimes(1);

    jest.restoreAllMocks();
  });
});
```

  </action>
  <verify>
    <automated>cd "/c/Users/maser/Lapse Clone" && npx jest __tests__/services/darkroomService.test.js --no-coverage 2>&1 | tail -20</automated>
    <manual>Confirm that the new cache behavior tests FAIL with "clearRevealCache is not a function" or similar — this is expected RED state before implementation. Existing tests (getDarkroom, isDarkroomReadyToReveal basic, scheduleNextReveal, ensureDarkroomInitialized) must still pass.</manual>
    <sampling_rate>Run immediately after this task before proceeding to Plan 02</sampling_rate>
  </verify>
  <done>New describe blocks appended; existing 15 tests still pass; new cache tests fail because clearRevealCache doesn't exist yet; createMockTimestamp now includes toMillis method</done>
</task>

</tasks>

<verification>
Run `npx jest __tests__/services/darkroomService.test.js --no-coverage` and confirm:
- Existing tests (getDarkroom, isDarkroomReadyToReveal basic cases, scheduleNextReveal, ensureDarkroomInitialized) all pass
- New cache behavior tests fail with a meaningful error (not a syntax error) — RED state confirmed
</verification>

<success_criteria>

- Test file updated with clearRevealCache import and cache behavior describe blocks
- createMockTimestamp helper includes toMillis method
- Existing 15 tests pass; new ~5 cache tests fail (RED) because implementation doesn't exist yet
  </success_criteria>

<output>
After completion, create `.planning/phases/06-tech-debt-darkroom-optimization/06-01-SUMMARY.md`
</output>
