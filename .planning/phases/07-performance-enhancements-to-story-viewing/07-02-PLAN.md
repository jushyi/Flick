---
phase: 07-performance-enhancements-to-story-viewing
plan: 02
type: execute
wave: 1
depends_on:
  - 07-00
files_modified:
  - src/hooks/usePhotoDetailModal.js
  - src/screens/PhotoDetailScreen.js
autonomous: true
requirements:
  - PERF-03
must_haves:
  truths:
    - "Friend-to-friend cube rotation runs at 60fps on both iOS and Android"
    - "Interactive swipe gesture drives the cube rotation on the UI thread without JS thread blocking"
    - "Cube transition completes smoothly even when JS thread is busy with data updates"
    - "Cancelled swipe springs back to original position without visual glitches"
    - "Dismiss (swipe-down) and expand animations continue to work unchanged"
    - "Within-friend photo taps remain instant with no animation"
    - "Android back button/gesture triggers the suck-back dismiss animation (same as swipe-down)"
  artifacts:
    - path: "src/hooks/usePhotoDetailModal.js"
      provides: "Gesture Handler pan gesture replacing PanResponder for horizontal swipes"
      contains: "Gesture.Pan"
    - path: "src/screens/PhotoDetailScreen.js"
      provides: "Reanimated useAnimatedStyle for cube face transforms"
      contains: "useAnimatedStyle"
  key_links:
    - from: "src/hooks/usePhotoDetailModal.js"
      to: "src/screens/PhotoDetailScreen.js"
      via: "Shared cubeProgress SharedValue driven by gesture and consumed by animated styles"
      pattern: "useSharedValue|cubeProgress"
    - from: "src/hooks/usePhotoDetailModal.js"
      to: "react-native-gesture-handler"
      via: "Gesture.Pan for interactive horizontal swipe"
      pattern: "Gesture\\.Pan"
---

<objective>
Migrate the 3D cube transition from React Native's Animated API + PanResponder to react-native-reanimated SharedValues + react-native-gesture-handler for UI-thread animation performance.

Purpose: The cube transition currently runs on the JS thread via Animated.timing and PanResponder, causing frame drops when the JS thread is busy with Firestore updates or React re-renders. Migrating to Reanimated worklets and Gesture Handler ensures 60fps cube rotations immune to JS thread blocking.
Output: PhotoDetailScreen cube faces use useAnimatedStyle with Reanimated interpolations; horizontal swipe gesture handled by Gesture.Pan running entirely on the UI thread.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-performance-enhancements-to-story-viewing/07-CONTEXT.md
@.planning/phases/07-performance-enhancements-to-story-viewing/07-RESEARCH.md
@src/screens/PhotoDetailScreen.js
@src/hooks/usePhotoDetailModal.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate cube progress to Reanimated SharedValue and cube face transforms to useAnimatedStyle</name>
  <files>src/screens/PhotoDetailScreen.js</files>
  <action>
Migrate the cube transition animation in PhotoDetailScreen from RN Animated to Reanimated:

1. Add Reanimated imports:
   ```javascript
   import Animated as ReanimatedView, {
     useSharedValue,
     useAnimatedStyle,
     withTiming,
     withSpring,
     interpolate,
     Easing as ReanimatedEasing,
     runOnJS,
   } from 'react-native-reanimated';
   ```
   IMPORTANT: The existing code uses `Animated` from react-native for translateY, opacity, openProgress, dismissScale, suckTranslateX. These STAY on RN Animated (they work fine — only the cube needs migration). To avoid naming conflicts, import Reanimated's Animated component as `ReanimatedView` (only used for the cube face wrapper Views).

2. Replace the `cubeProgress` ref initialization:
   - OLD: `const cubeProgress = useRef(new Animated.Value(1)).current;`
   - NEW: `const cubeProgress = useSharedValue(1);`

3. Add a `transitionDirectionValue` SharedValue to track direction on the UI thread:
   ```javascript
   const transitionDirectionValue = useSharedValue(1); // 1 = forward, -1 = backward
   ```
   Update `setTransitionDirection` calls to also set this shared value:
   - When direction is 'forward': `transitionDirectionValue.value = 1;`
   - When direction is 'backward': `transitionDirectionValue.value = -1;`

4. Create `useAnimatedStyle` hooks for both cube faces:

   **Incoming face style:**
   ```javascript
   const incomingCubeStyle = useAnimatedStyle(() => {
     const dir = transitionDirectionValue.value; // 1=forward, -1=backward
     return {
       backfaceVisibility: 'hidden',
       transform: [
         { perspective: 650 },
         { translateX: interpolate(cubeProgress.value, [0, 1], [dir * SCREEN_WIDTH, 0]) },
         { translateX: -dir * (SCREEN_WIDTH / 2) },
         { rotateY: `${interpolate(cubeProgress.value, [0, 1], [dir * 90, 0])}deg` },
         { translateX: dir * (SCREEN_WIDTH / 2) },
       ],
     };
   });
   ```

   **Outgoing face style:**
   ```javascript
   const outgoingCubeStyle = useAnimatedStyle(() => {
     const dir = transitionDirectionValue.value;
     return {
       position: 'absolute',
       top: 0, left: 0, right: 0, bottom: 0,
       backfaceVisibility: 'hidden',
       transform: [
         { perspective: 650 },
         { translateX: interpolate(cubeProgress.value, [0, 1], [0, -dir * SCREEN_WIDTH]) },
         { translateX: dir * (SCREEN_WIDTH / 2) },
         { rotateY: `${interpolate(cubeProgress.value, [0, 1], [0, -dir * 90])}deg` },
         { translateX: -dir * (SCREEN_WIDTH / 2) },
       ],
     };
   });
   ```

5. Replace the two cube face `<Animated.View>` wrappers in the JSX:
   - The incoming face (main content wrapper): Change from `<Animated.View style={[styles.contentWrapper, { backfaceVisibility: 'hidden', transform: [...] }]}>` to `<ReanimatedView style={[styles.contentWrapper, incomingCubeStyle]}>` ... `</ReanimatedView>`
   - The outgoing face (snapshot): Change from `<Animated.View pointerEvents="none" style={[styles.contentWrapper, { position: 'absolute', ... transform: [...] }]}>` to `<ReanimatedView pointerEvents="none" style={[styles.contentWrapper, outgoingCubeStyle]}>` ... `</ReanimatedView>`

6. Update cube animation calls to use Reanimated's `withTiming`:
   - In `handleFriendTransition`: Replace `Animated.timing(cubeProgress, {...}).start(callback)` with:
     ```javascript
     cubeProgress.value = 0; // snap to start
     // requestAnimationFrame still needed for React to render new friend data
     requestAnimationFrame(() => {
       cubeProgress.value = withTiming(1, {
         duration: 250,
         easing: ReanimatedEasing.out(ReanimatedEasing.cubic),
       }, (finished) => {
         if (finished) {
           runOnJS(handleTransitionComplete)();
         }
       });
     });
     ```
     Extract the transition complete callback into a separate function:
     ```javascript
     const handleTransitionComplete = useCallback(() => {
       isTransitioningRef.current = false;
       setIsTransitioning(false);
     }, []);
     ```

   - Same pattern for `handlePreviousFriendTransition` — use `withTiming` + `runOnJS`.

   - In `handleCancelSwipeTransition`: Replace `cubeProgress.setValue(1)` with `cubeProgress.value = 1;`

7. Update the `useEffect` that resets cube state on mount:
   - Replace `cubeProgress.setValue(1)` with `cubeProgress.value = 1;`

8. Remove the `transitionDirection` from the inline style objects — the animated styles computed via `useAnimatedStyle` now handle direction internally via `transitionDirectionValue`.

9. The existing RN `Animated.View` wrappers for the expand/collapse animation (the outer wrapper with translateY, opacity, scale) STAY as RN Animated. Only the inner cube face wrappers change to ReanimatedView. This is important — do not break the expand/collapse animation.

CRITICAL CONSTRAINTS:
- Do NOT touch the dismiss (swipe-down), expand (open), or suck-back (close) animations — they stay on RN Animated
- Do NOT touch the PanResponder vertical gesture handling (swipe up/down) — it stays as-is in this plan
- Only the cube face TRANSFORMS and cube TIMING animations change
- The PanResponder's horizontal swipe tracking (`cubeProgress.setValue(progress)`) needs updating to use `.value =` assignment instead — this is handled in the next part
  </action>
  <verify>
    <automated>cd "C:/Users/maser/Lapse Clone" && npx eslint src/screens/PhotoDetailScreen.js --no-error-on-unmatched-pattern</automated>
    <manual>Open stories mode, swipe between friends — cube should rotate smoothly at 60fps. Swipe down to dismiss — should still work. Tap left/right — within-friend navigation should still work instantly.</manual>
  </verify>
  <done>Cube face transforms run via Reanimated useAnimatedStyle on the UI thread. Cube timing animations use withTiming instead of Animated.timing. Forward and backward cube transitions work correctly. Dismiss and expand animations are unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate horizontal swipe gesture from PanResponder to Gesture Handler + Reanimated</name>
  <files>src/hooks/usePhotoDetailModal.js, src/screens/PhotoDetailScreen.js</files>
  <action>
Migrate the interactive horizontal swipe (friend-to-friend cube tracking) from PanResponder to Gesture Handler, while keeping the vertical swipe gestures on PanResponder:

**In usePhotoDetailModal.js:**

1. Add imports:
   ```javascript
   import { Gesture } from 'react-native-gesture-handler';
   import { withTiming, withSpring, Easing as ReanimatedEasing, runOnJS } from 'react-native-reanimated';
   ```

2. The hook receives `cubeProgress` which is now a SharedValue (not Animated.Value). Update references:
   - All `cubeProgressRef.current.setValue(progress)` → `cubeProgressRef.current.value = progress`
   - All `Animated.timing(cubeProgressRef.current, {...}).start(cb)` → use withTiming on cubeProgressRef.current.value with runOnJS for callbacks
   - All `Animated.spring(cubeProgressRef.current, {...}).start(cb)` → use withSpring on cubeProgressRef.current.value with runOnJS for callbacks

3. Extract the horizontal swipe logic from PanResponder into a separate `Gesture.Pan()`:

   ```javascript
   const horizontalGesture = useMemo(() => {
     return Gesture.Pan()
       .activeOffsetX([-15, 15])  // Only activate on horizontal movement
       .failOffsetY([-10, 10])    // Fail if vertical movement exceeds this
       .onStart(() => {
         'worklet';
       })
       .onUpdate((event) => {
         'worklet';
         const { translationX } = event;
         // Determine direction
         if (!isHorizontalSwipeActiveRef.current) {
           // First significant horizontal movement — prepare transition
           const direction = translationX < 0 ? 'forward' : 'backward';
           runOnJS(prepareHorizontalSwipe)(direction, Math.abs(translationX));
           return;
         }
         // Drive cube progress from gesture
         const signedDx = swipeDirectionRef.current === 'forward' ? -translationX : translationX;
         const adjustedDx = Math.max(0, signedDx - 15);
         const progress = Math.min(1, adjustedDx / SCREEN_WIDTH);
         cubeProgressRef.current.value = progress;
       })
       .onEnd((event) => {
         'worklet';
         if (!isHorizontalSwipeActiveRef.current) return;
         runOnJS(completeHorizontalSwipe)(event.translationX, event.velocityX);
       })
       .onFinalize(() => {
         'worklet';
         // Handle gesture cancellation
       });
   }, []);
   ```

   Create helper functions called via `runOnJS`:
   ```javascript
   const prepareHorizontalSwipe = useCallback((direction, absDx) => {
     // Same logic as current PanResponder horizontal detection
     const hasCallback = direction === 'forward'
       ? onFriendTransitionRef.current
       : onPreviousFriendTransitionRef.current;
     if (!hasCallback || !onPrepareSwipeTransitionRef.current) return;

     const prepared = onPrepareSwipeTransitionRef.current(direction);
     if (!prepared) return;

     isHorizontalSwipeActiveRef.current = true;
     swipeDirectionRef.current = direction;
   }, []);

   const completeHorizontalSwipe = useCallback((dx, vx) => {
     // Same commit/cancel logic as current PanResponder release
     const signedDx = swipeDirectionRef.current === 'forward' ? -dx : dx;
     const clampedDx = Math.max(0, signedDx);
     const signedVx = swipeDirectionRef.current === 'forward' ? -vx : vx;
     const forwardVx = Math.max(0, signedVx);

     const COMMIT_DISTANCE_THRESHOLD = SCREEN_WIDTH * 0.25;
     const COMMIT_VELOCITY_THRESHOLD = 0.4;
     const shouldCommit = clampedDx > COMMIT_DISTANCE_THRESHOLD || forwardVx > COMMIT_VELOCITY_THRESHOLD;

     if (shouldCommit && cubeProgressRef.current) {
       cubeProgressRef.current.value = withTiming(1, {
         duration: 150,
         easing: ReanimatedEasing.out(ReanimatedEasing.cubic),
       }, () => {
         runOnJS(onCommitSwipeTransitionRef.current)?.();
       });
     } else if (cubeProgressRef.current) {
       cubeProgressRef.current.value = withSpring(0, {
         damping: 18,
         stiffness: 200,
       }, () => {
         runOnJS(onCancelSwipeTransitionRef.current)?.();
       });
     }

     isHorizontalSwipeActiveRef.current = false;
     swipeDirectionRef.current = null;
   }, []);
   ```

4. Remove ALL horizontal swipe handling from the PanResponder. The PanResponder should ONLY handle:
   - Vertical swipes (swipe-down to dismiss, swipe-up to open comments)
   - The existing `onMoveShouldSetPanResponder` should no longer check for horizontal swipes
   - Remove `isHorizontalSwipeActiveRef` checks from PanResponder's `onPanResponderMove` and `onPanResponderRelease`
   - Remove `gestureLockRef` horizontal branch — only 'vertical' lock remains

5. Return the `horizontalGesture` from the hook alongside existing returns:
   ```javascript
   return {
     // ... existing returns
     horizontalGesture, // New: Gesture.Pan for friend-to-friend swipe
   };
   ```

**In PhotoDetailScreen.js:**

6. Add GestureDetector import:
   ```javascript
   import { GestureDetector } from 'react-native-gesture-handler';
   ```

7. Destructure `horizontalGesture` from `usePhotoDetailModal()` return.

8. Wrap the main content area (the incoming cube face ReanimatedView) with `<GestureDetector gesture={horizontalGesture}>`:
   ```jsx
   <GestureDetector gesture={horizontalGesture}>
     <ReanimatedView style={[styles.contentWrapper, incomingCubeStyle]}>
       {/* ... existing content ... */}
     </ReanimatedView>
   </GestureDetector>
   ```
   The GestureDetector only wraps the incoming face — the outgoing face is pointer-events none and doesn't need gesture handling.

9. Make sure the PanResponder (still on the outer View for vertical gestures) and GestureDetector (on the inner cube face for horizontal gestures) don't conflict. The `activeOffsetX` and `failOffsetY` on the Gesture.Pan ensure it only activates on horizontal movement, while PanResponder only activates on vertical movement.

CRITICAL CONSTRAINTS:
- PanResponder continues to handle vertical gestures (dismiss down, open comments up)
- Gesture.Pan handles ONLY horizontal swipes (friend-to-friend transitions)
- Do NOT use worklet functions to read React state — use `runOnJS` for all state updates
- The `cubeProgress` SharedValue is shared between the gesture (writes) and the animated styles (reads)
- Android back button handling is in the next task (Task 3)
  </action>
  <verify>
    <automated>cd "C:/Users/maser/Lapse Clone" && npx eslint src/hooks/usePhotoDetailModal.js src/screens/PhotoDetailScreen.js --no-error-on-unmatched-pattern</automated>
    <manual>In stories mode: (1) Swipe horizontally between friends — cube rotates interactively following finger. (2) Swipe down — modal dismisses with suck-back. (3) Swipe up — comments open. (4) Half-swipe horizontal then release — cube springs back. (5) Test on Android device for 60fps smoothness.</manual>
  </verify>
  <done>Horizontal cube swipe runs entirely on the UI thread via Gesture.Pan + Reanimated SharedValue. Vertical gestures (dismiss, comments) still work via PanResponder. Interactive swipe tracking is smooth at 60fps. Commit and cancel animations use withTiming/withSpring.</done>
</task>

<task type="auto">
  <name>Task 3: Wire Android back button to trigger suck-back dismiss animation</name>
  <files>src/screens/PhotoDetailScreen.js</files>
  <action>
Add a BackHandler listener on Android so the hardware back button/gesture triggers the same suck-back dismiss animation as swipe-down. Per CONTEXT.md locked decision: "Android back button/gesture triggers the same suck-back dismiss animation as swipe-down."

1. Add import at the top of PhotoDetailScreen.js:
   ```javascript
   import { Platform, BackHandler } from 'react-native';
   ```
   (BackHandler may already be imported — if not, add it.)

2. Add a `useFocusEffect` (or `useEffect` with `visible` dependency) that registers a BackHandler listener when the PhotoDetail modal is visible on Android:
   ```javascript
   useEffect(() => {
     if (Platform.OS !== 'android' || !visible) return;

     const onBackPress = () => {
       // Trigger the same dismiss as swipe-down
       handleDismiss(); // or whatever the existing dismiss function is called
       return true; // Prevent default back behavior
     };

     BackHandler.addEventListener('hardwareBackPress', onBackPress);
     return () => BackHandler.removeEventListener('hardwareBackPress', onBackPress);
   }, [visible, handleDismiss]);
   ```

3. Find the existing dismiss function — this is the same function called when the user swipes down past the dismiss threshold. It triggers the suck-back animation (scale down + translate to origin). Wire the BackHandler to call this exact function.

4. Make sure the BackHandler listener is removed on unmount and when the modal becomes invisible. The useEffect cleanup handles this.

CRITICAL CONSTRAINTS:
- Only add the BackHandler on Android (Platform.OS guard)
- Call the EXISTING dismiss function — do NOT create a new dismiss path
- The suck-back animation should play exactly as it does for swipe-down dismiss
- Do NOT interfere with React Navigation's default back handling for other screens
  </action>
  <verify>
    <automated>cd "C:/Users/maser/Lapse Clone" && npx eslint src/screens/PhotoDetailScreen.js --no-error-on-unmatched-pattern</automated>
    <manual>On Android device or emulator: (1) Open a photo in stories mode. (2) Press the hardware back button or swipe the back gesture. (3) The photo detail should dismiss with the suck-back animation (same as swipe-down dismiss). (4) On iOS, behavior should be unchanged.</manual>
  </verify>
  <done>Android hardware back button triggers the suck-back dismiss animation on PhotoDetailScreen. iOS behavior is unchanged. BackHandler listener is properly registered and cleaned up.</done>
</task>

</tasks>

<verification>
1. Open stories mode, tap through photos within a friend — instant swap, no animation (unchanged)
2. Tap past last photo — cube rotates to next friend at 60fps
3. Swipe horizontally — interactive cube tracking follows finger smoothly
4. Half-swipe then release — cube springs back to original friend
5. Swipe down — modal dismisses with suck-back animation (unchanged)
6. Swipe up — comments open (unchanged)
7. Test on Android device — cube rotation is smooth without frame drops
8. Press Android back button in photo detail — suck-back dismiss animation plays
9. ESLint passes on all modified files
</verification>

<success_criteria>
- Cube face transforms computed via Reanimated useAnimatedStyle on UI thread
- Horizontal swipe gesture handled by Gesture.Pan (not PanResponder)
- Cube progress driven by SharedValue (not Animated.Value)
- Vertical gestures (dismiss, comments) unchanged and working
- No visual regressions in expand, dismiss, or suck-back animations
- 60fps cube transition on both iOS and Android
- Android back button triggers suck-back dismiss animation
</success_criteria>

<output>
After completion, create `.planning/phases/07-performance-enhancements-to-story-viewing/07-02-SUMMARY.md`
</output>
