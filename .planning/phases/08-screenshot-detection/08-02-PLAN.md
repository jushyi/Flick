---
phase: 08-screenshot-detection
plan: 02
type: execute
wave: 2
depends_on:
  - 08-01
files_modified:
  - src/hooks/useScreenshotDetection.js
  - src/components/SystemMessage.js
  - src/components/SnapViewer.js
  - src/screens/ConversationScreen.js
autonomous: true
requirements:
  - SCRN-01
  - SCRN-02
  - SCRN-03

must_haves:
  truths:
    - "When a recipient screenshots while viewing a snap, the sender receives a push notification"
    - "Both users see a system message in the conversation: 'Alex screenshotted a snap'"
    - "System message is styled as small centered gray text matching date separators"
    - "Screenshot detection only activates for the recipient viewing an active snap (not sender, not expired)"
    - "Self-screenshots are ignored"
    - "Offline screenshot events are queued and processed when connectivity returns"
    - "The snap message document has a screenshottedAt timestamp after a screenshot event"
  artifacts:
    - path: "src/hooks/useScreenshotDetection.js"
      provides: "Hook wrapping expo-screen-capture listener with activation/deactivation control"
      exports: ["useScreenshotDetection"]
    - path: "src/components/SystemMessage.js"
      provides: "System message renderer matching TimeDivider style"
      exports: ["default"]
    - path: "src/components/SnapViewer.js"
      provides: "SnapViewer with integrated screenshot detection"
      contains: "useScreenshotDetection"
    - path: "src/screens/ConversationScreen.js"
      provides: "ConversationScreen rendering SystemMessage items in the message list"
      contains: "SystemMessage"
  key_links:
    - from: "src/hooks/useScreenshotDetection.js"
      to: "expo-screen-capture"
      via: "addScreenshotListener subscription"
      pattern: "ScreenCapture\\.addScreenshotListener"
    - from: "src/components/SnapViewer.js"
      to: "src/hooks/useScreenshotDetection.js"
      via: "useScreenshotDetection hook activation"
      pattern: "useScreenshotDetection"
    - from: "src/components/SnapViewer.js"
      to: "src/services/firebase/screenshotService.js"
      via: "recordScreenshot call on screenshot detection"
      pattern: "recordScreenshot"
    - from: "src/screens/ConversationScreen.js"
      to: "src/components/SystemMessage.js"
      via: "renderItem delegates system messages to SystemMessage"
      pattern: "system_screenshot.*SystemMessage"
---

<objective>
Create the screenshot detection hook, SystemMessage component, and wire everything into SnapViewer and ConversationScreen for a complete end-to-end screenshot detection experience.

Purpose: Connects the data pipeline (Plan 01) to the user-facing UI — detection in SnapViewer triggers Firestore writes, system messages appear in conversations, and offline events are retried.
Output: useScreenshotDetection hook, SystemMessage component, updated SnapViewer and ConversationScreen.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-screenshot-detection/08-CONTEXT.md
@.planning/phases/08-screenshot-detection/08-RESEARCH.md
@.planning/phases/08-screenshot-detection/08-01-SUMMARY.md
@src/components/SnapViewer.js
@src/components/TimeDivider.js
@src/screens/ConversationScreen.js
@src/services/firebase/screenshotService.js
@src/services/screenshotQueueService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useScreenshotDetection hook and SystemMessage component</name>
  <files>
    src/hooks/useScreenshotDetection.js
    src/components/SystemMessage.js
  </files>
  <action>
**Step 1: Create `src/hooks/useScreenshotDetection.js`**

A custom hook that wraps `expo-screen-capture`'s `addScreenshotListener`. The hook activates/deactivates the listener based on an `active` boolean and calls an `onScreenshot` callback when a screenshot is detected.

```js
import * as ScreenCapture from 'expo-screen-capture';
import { useEffect, useRef, useCallback } from 'react';
import logger from '../utils/logger';
```

Hook signature: `useScreenshotDetection({ active, onScreenshot })`

Implementation details:
1. Use a `listenerRef` (useRef) to hold the subscription object
2. Use an `alreadyDetectedRef` (useRef, boolean) to prevent duplicate callbacks within the same activation cycle — resets to `false` when `active` changes to `true`
3. When `active` becomes `true`:
   - Reset `alreadyDetectedRef.current = false`
   - Call `ScreenCapture.addScreenshotListener(() => { ... })` and store in `listenerRef`
   - Inside the listener callback: if `alreadyDetectedRef.current` is true, return early (debounce). Otherwise set `alreadyDetectedRef.current = true` and call `onScreenshot()`
4. When `active` becomes `false` or on cleanup:
   - Call `listenerRef.current?.remove()` and set to null
5. Wrap the listener setup in a try/catch — if `addScreenshotListener` throws (e.g., API unavailable on some Android devices), log a warning and fail silently per user decision

Export the hook as default.

**Step 2: Create `src/components/SystemMessage.js`**

A minimal component that renders system messages in the conversation. Styled identically to TimeDivider (small centered gray text, standard UI font).

Props: `{ text }` — the system message text string.

Implementation:
```jsx
import React from 'react';
import { Text, StyleSheet } from 'react-native';
import { colors } from '../constants/colors';
import { typography } from '../constants/typography';

const SystemMessage = ({ text }) => {
  if (!text) return null;
  return <Text style={styles.text}>{text}</Text>;
};

const styles = StyleSheet.create({
  text: {
    fontSize: 10,
    color: colors.text.secondary,
    fontFamily: typography.fontFamily.body,
    textAlign: 'center',
    marginVertical: 16,
    paddingHorizontal: 16,
  },
});

export default SystemMessage;
```

This is intentionally identical to TimeDivider's styling per user decision: "Small centered gray text, same style as date separators in the conversation. Standard UI font (not pixel art font). No inline timestamp."
  </action>
  <verify>
    <automated>npm run lint -- --quiet src/hooks/useScreenshotDetection.js src/components/SystemMessage.js 2>&1 | tail -10</automated>
    <manual>Verify useScreenshotDetection.js exports hook with active/onScreenshot params. Verify SystemMessage.js renders text with TimeDivider-matching styles.</manual>
  </verify>
  <done>useScreenshotDetection hook wraps expo-screen-capture listener with activation control, debounce via alreadyDetectedRef, and silent failure on unsupported devices. SystemMessage component renders system messages as small centered gray text matching TimeDivider style exactly.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate screenshot detection into SnapViewer and render system messages in ConversationScreen</name>
  <files>
    src/components/SnapViewer.js
    src/screens/ConversationScreen.js
  </files>
  <action>
**Step 1: Wire useScreenshotDetection into SnapViewer**

Modify `src/components/SnapViewer.js`:

1. Add imports:
   ```js
   import useScreenshotDetection from '../hooks/useScreenshotDetection';
   import { recordScreenshot } from '../services/firebase/screenshotService';
   import { queueScreenshotEvent, processScreenshotQueue } from '../services/screenshotQueueService';
   ```

2. The SnapViewer component already receives `currentUserId`, `snapMessage`, `conversationId`, and `senderName` as props. It also has an `isRecipient` check (line ~214). Use this to determine if detection should be active.

3. Add a `screenshotterName` derivation. SnapViewer does not currently have the viewer's display name. **Add a new prop `viewerDisplayName`** to SnapViewer. This will be passed from ConversationScreen (where `userProfile.displayName` is available).

4. Compute detection activation:
   ```js
   const isActiveSnap = snapMessage && snapMessage.type === 'snap' && !snapMessage.screenshottedAt;
   const isExpired = snapMessage?.expiresAt?.toDate?.() < new Date();
   const detectionActive = visible && isRecipient && isActiveSnap && !isExpired;
   ```
   - `visible`: viewer is open
   - `isRecipient`: viewer is not the sender (self-screenshots ignored per user decision)
   - `isActiveSnap`: snap hasn't been screenshotted already (first-only per user decision)
   - `!isExpired`: expired snaps are ignored per user decision

5. Define the screenshot handler with `useCallback`:
   ```js
   const handleScreenshot = useCallback(async () => {
     if (!conversationId || !snapMessage?.id || !currentUserId || !viewerDisplayName) return;

     logger.info('SnapViewer: Screenshot detected', {
       conversationId,
       snapMessageId: snapMessage.id,
     });

     const result = await recordScreenshot({
       conversationId,
       snapMessageId: snapMessage.id,
       screenshotterId: currentUserId,
       screenshotterName: viewerDisplayName,
     });

     if (!result.success && result.error) {
       // Network failure — queue for retry
       logger.warn('SnapViewer: Screenshot recording failed, queueing for retry', {
         error: result.error,
       });
       await queueScreenshotEvent({
         conversationId,
         snapMessageId: snapMessage.id,
         screenshotterId: currentUserId,
         screenshotterName: viewerDisplayName,
       });
     }
   }, [conversationId, snapMessage?.id, currentUserId, viewerDisplayName]);
   ```

6. Call the hook:
   ```js
   useScreenshotDetection({ active: detectionActive, onScreenshot: handleScreenshot });
   ```

7. Add a `useEffect` that runs `processScreenshotQueue()` when the SnapViewer opens (when `visible` changes to `true`). This processes any queued offline events from previous sessions:
   ```js
   useEffect(() => {
     if (visible) {
       processScreenshotQueue();
     }
   }, [visible]);
   ```

**Step 2: Update ConversationScreen to pass viewerDisplayName to SnapViewer**

In ConversationScreen, update the SnapViewer render to include the new prop:
```jsx
<SnapViewer
  visible={!!snapViewerMessage}
  snapMessage={snapViewerMessage}
  conversationId={conversationId}
  senderName={liveFriendProfile?.displayName || liveFriendProfile?.username || 'Friend'}
  onClose={() => setSnapViewerMessage(null)}
  currentUserId={user.uid}
  viewerDisplayName={userProfile?.displayName || userProfile?.username || 'Someone'}
  onReaction={...}
/>
```

**Step 3: Render system messages in ConversationScreen**

1. Add import at top of ConversationScreen:
   ```js
   import SystemMessage from '../components/SystemMessage';
   ```

2. In the `messagesWithDividers` useMemo, system messages are already included as regular message items (they come from the messages subcollection subscription). No filtering change needed — they flow through as normal messages.

3. In the `renderItem` callback, add a check for `system_screenshot` type BEFORE the MessageBubble render. System messages should NOT be rendered as MessageBubble (which assumes senderId for layout). Insert this check early in renderItem:

   ```js
   // After the divider check:
   if (item.type === 'system_screenshot') {
     return (
       <View style={styles.messageWrapper}>
         <SystemMessage text={item.text} />
       </View>
     );
   }
   ```

   Place this AFTER the `item.itemType === 'divider'` check and BEFORE the `isCurrentUser` derivation. This prevents the MessageBubble from trying to render a system message (which would crash on isCurrentUser check since the senderId is the screenshotter, not a traditional sender).

4. **Also filter system messages from lastSentMessage computation**: System messages should not be considered as "sent messages" for read receipt purposes. Update the `lastSentMessage` useMemo:
   ```js
   const lastSentMessage = useMemo(
     () => messages.find(m => m.senderId === user.uid && m.type !== 'system_screenshot'),
     [messages, user.uid]
   );
   ```

5. **Filter system messages from reaction/action menu interactions**: In the press handler logic, system messages should not have any interaction handlers (no timestamp toggle, no action menu, no reactions). The early return in renderItem (step 3) already handles this — system messages never reach the press handler code.
  </action>
  <verify>
    <automated>npm run lint -- --quiet src/components/SnapViewer.js src/screens/ConversationScreen.js 2>&1 | tail -10</automated>
    <manual>Open the app. Send a snap to a friend. Open the snap as the recipient. Take a screenshot. Verify: (1) system message appears in conversation, (2) sender receives push notification, (3) screenshottedAt field exists on snap document in Firestore.</manual>
  </verify>
  <done>SnapViewer activates screenshot detection via useScreenshotDetection hook when recipient views an active snap. Screenshot events write screenshottedAt + system message to Firestore, with offline queueing on failure. ConversationScreen renders system messages as centered gray text matching date separator style. Self-screenshots and repeat screenshots are ignored. Expired snaps are excluded from detection.</done>
</task>

</tasks>

<verification>
1. `src/hooks/useScreenshotDetection.js` exists with hook that wraps expo-screen-capture listener
2. `src/components/SystemMessage.js` exists with TimeDivider-matching style
3. `src/components/SnapViewer.js` integrates useScreenshotDetection with proper activation guards
4. `src/screens/ConversationScreen.js` renders SystemMessage for system_screenshot type items
5. No lint errors: `npm run lint -- --quiet`
6. Full end-to-end flow: recipient screenshots snap -> screenshottedAt written -> system message created -> push notification sent to sender -> both users see system message in conversation
</verification>

<success_criteria>
- Taking a screenshot while viewing a snap as the recipient triggers the full flow
- System message "Alex screenshotted a snap" appears in the conversation for both users
- System message styled as small centered gray text (same as date separators)
- Sender receives push notification: "Alex screenshotted your snap"
- Tapping notification opens the conversation
- Only first screenshot triggers (subsequent screenshots of same snap are silent)
- Self-screenshots (sender viewing own snap) do not trigger detection
- Expired/deleted snaps do not trigger detection
- Offline screenshot events are queued and retried on next SnapViewer open
</success_criteria>

<output>
After completion, create `.planning/phases/08-screenshot-detection/08-02-SUMMARY.md`
</output>
