---
phase: 08-screenshot-detection
plan: 00
type: execute
wave: 0
depends_on: []
files_modified:
  - __tests__/setup/jest.setup.js
  - __tests__/services/screenshotService.test.js
  - functions/__tests__/triggers/screenshotNotification.test.js
autonomous: true
requirements:
  - SCRN-01
  - SCRN-02
  - SCRN-03

must_haves:
  truths:
    - "screenshotService.test.js has RED tests for screenshottedAt write, system message creation, and idempotency"
    - "screenshotNotification.test.js has RED tests for onNewMessage handling of system_screenshot type including push to sender"
    - "expo-screen-capture mock is registered in jest.setup.js so hook-level tests can import the module"
  artifacts:
    - path: "__tests__/services/screenshotService.test.js"
      provides: "RED unit tests for screenshotService behaviors"
      contains: "recordScreenshot"
    - path: "functions/__tests__/triggers/screenshotNotification.test.js"
      provides: "RED unit tests for onNewMessage system_screenshot handling"
      contains: "system_screenshot"
    - path: "__tests__/setup/jest.setup.js"
      provides: "expo-screen-capture mock alongside existing Expo module mocks"
      contains: "expo-screen-capture"
  key_links:
    - from: "__tests__/services/screenshotService.test.js"
      to: "src/services/firebase/screenshotService.js"
      via: "imports recordScreenshot (will fail until 08-01 creates the module)"
      pattern: "require.*screenshotService"
    - from: "functions/__tests__/triggers/screenshotNotification.test.js"
      to: "functions/index.js"
      via: "imports onNewMessage and tests system_screenshot branch"
      pattern: "require.*index.*onNewMessage"
---

<objective>
Create test scaffolds (RED tests) for all Phase 8 screenshot detection behaviors before implementation begins.

Purpose: Establishes the Nyquist verification layer so Plans 08-01 and 08-02 can use real test commands in their verify steps instead of --passWithNoTests. Tests are expected to FAIL (RED) until the corresponding implementation plans make them pass.
Output: screenshotService.test.js, screenshotNotification.test.js, expo-screen-capture mock in jest.setup.js.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-screenshot-detection/08-CONTEXT.md
@.planning/phases/08-screenshot-detection/08-RESEARCH.md
@__tests__/setup/jest.setup.js
@__tests__/services/snapService.test.js
@functions/__tests__/triggers/notifications.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add expo-screen-capture mock to jest.setup.js</name>
  <files>
    __tests__/setup/jest.setup.js
  </files>
  <action>
Add an `expo-screen-capture` mock to `__tests__/setup/jest.setup.js` in the "Expo Modules Mocks" section (after the existing expo-camera mock, around line 379).

The mock should provide:
1. `addScreenshotListener` — a jest.fn() that returns `{ remove: jest.fn() }` (matching the subscription pattern)
2. `usePreventScreenCapture` — a jest.fn() (no-op, not used in phase 8 but include for completeness)
3. `preventScreenCaptureAsync` — a jest.fn() returning Promise.resolve()
4. `allowScreenCaptureAsync` — a jest.fn() returning Promise.resolve()

```js
// expo-screen-capture
const mockAddScreenshotListener = jest.fn(() => ({ remove: jest.fn() }));

jest.mock('expo-screen-capture', () => ({
  addScreenshotListener: mockAddScreenshotListener,
  usePreventScreenCapture: jest.fn(),
  preventScreenCaptureAsync: jest.fn(() => Promise.resolve()),
  allowScreenCaptureAsync: jest.fn(() => Promise.resolve()),
}));

global.mockAddScreenshotListener = mockAddScreenshotListener;
```

Export the mock function globally following the project pattern so tests can configure return values.
  </action>
  <verify>
    <automated>npx jest __tests__/services/smoke.test.js --verbose 2>&1 | tail -10</automated>
    <manual>Verify jest.setup.js has expo-screen-capture mock in the Expo Modules section</manual>
  </verify>
  <done>expo-screen-capture is mocked in jest.setup.js with addScreenshotListener returning a subscription object with remove(). Mock function exported globally as mockAddScreenshotListener.</done>
</task>

<task type="auto">
  <name>Task 2: Create RED test file for screenshotService</name>
  <files>
    __tests__/services/screenshotService.test.js
  </files>
  <action>
Create `__tests__/services/screenshotService.test.js` following the pattern in `snapService.test.js`.

**Mock setup** (at the top, before imports):
- Mock logger (same pattern as snapService.test.js)
- Mock `@react-native-firebase/firestore` with module-level mock functions: mockGetDoc, mockUpdateDoc, mockAddDoc, mockServerTimestamp, mockDoc, mockCollection, mockGetFirestore. Follow the exact pattern from snapService.test.js.

**Import under test:**
```js
const { recordScreenshot } = require('../../src/services/firebase/screenshotService');
```

**Test suite: `describe('screenshotService', () => { ... })`**

Write the following RED tests (they will fail because screenshotService.js does not exist yet):

1. **`describe('recordScreenshot', () => { ... })`**

   a. `it('writes screenshottedAt timestamp on the snap message document')` — Call `recordScreenshot({ conversationId: 'conv1', snapMessageId: 'snap1', screenshotterId: 'user2', screenshotterName: 'Alex' })`. Set mockGetDoc to return a snap document with `{ type: 'snap', screenshottedAt: null }` (no existing screenshot). Assert `mockUpdateDoc` was called with the snap doc ref and an object containing `screenshottedAt`.

   b. `it('creates a system_screenshot message in the conversation messages subcollection')` — Same call as (a). Assert `mockAddDoc` was called with a collection ref and an object containing `{ type: 'system_screenshot', senderId: 'user2', screenshotterId: 'user2', snapMessageId: 'snap1', text: expect.stringContaining('Alex') }`.

   c. `it('returns alreadyScreenshotted: true and does NOT create duplicate system message when screenshottedAt already exists')` — Set mockGetDoc to return `{ type: 'snap', screenshottedAt: { _seconds: 123 } }`. Call recordScreenshot. Assert result has `alreadyScreenshotted: true`. Assert `mockUpdateDoc` was NOT called. Assert `mockAddDoc` was NOT called.

   d. `it('returns skipped: true for non-snap message types')` — Set mockGetDoc to return `{ type: 'text' }`. Call recordScreenshot. Assert result has `skipped: true`. Assert `mockUpdateDoc` was NOT called.

   e. `it('returns { success: false, error } on Firestore write failure')` — Set mockUpdateDoc to reject with an Error. Call recordScreenshot. Assert result has `success: false` and `error` is a string.

These tests are expected to FAIL (RED) because `screenshotService.js` does not exist yet. The import will throw a module-not-found error. This is correct for Wave 0.
  </action>
  <verify>
    <automated>npx jest __tests__/services/screenshotService.test.js --verbose 2>&1 | tail -15</automated>
    <manual>Verify the test file exists and all 5 tests are listed. They should all FAIL (RED) because screenshotService.js does not exist yet.</manual>
  </verify>
  <done>screenshotService.test.js exists with 5 RED tests covering: screenshottedAt write, system message creation, idempotency (alreadyScreenshotted), non-snap skip, and error handling. All tests fail because the service module does not exist yet.</done>
</task>

<task type="auto">
  <name>Task 3: Create RED test file for screenshot notification Cloud Function</name>
  <files>
    functions/__tests__/triggers/screenshotNotification.test.js
  </files>
  <action>
Create `functions/__tests__/triggers/screenshotNotification.test.js` following the pattern in `functions/__tests__/triggers/notifications.test.js`.

**Mock setup** (same pattern as notifications.test.js):
- Mock `../../notifications/sender` with `mockSendPushNotification`
- Mock `../../notifications/batching` with `mockAddReactionToBatch`
- Require `firebase-admin/firestore` and get mockDb via `initializeFirestore()`
- Require `onNewMessage` from `../../index`

**Helper function:** `setupMockDb(config)` — same pattern as notifications.test.js. Must support:
- `users` object: keyed by userId, returns user profiles with `fcmToken`, `displayName`, `notificationSettings`
- `conversations` object: keyed by conversationId, returns conversation documents with `participants`, `mutedBy`

**Test suite: `describe('onNewMessage — system_screenshot type', () => { ... })`**

Write the following RED tests:

1. `it('sends push notification to snap sender (not screenshotter) for system_screenshot messages')` — Create a mock message document snapshot with `{ senderId: 'user2', type: 'system_screenshot', text: 'Alex screenshotted a snap', screenshotterId: 'user2', snapMessageId: 'snap1' }` in conversation `user1_user2`. Set up mockDb with user1 (snap sender, has fcmToken) and user2 (screenshotter). Invoke `onNewMessage`'s handler. Assert `mockSendPushNotification` was called with user1's fcmToken and body containing "screenshotted".

2. `it('does NOT send notification if conversation is muted by recipient')` — Same setup but the conversation has `mutedBy` including user1 (the snap sender). Assert `mockSendPushNotification` was NOT called.

3. `it('updates conversation lastMessage preview with the system message text')` — After invoking the handler, assert that mockDb's conversation document update was called with `lastMessage` containing the screenshot text and `updatedAt`.

These tests will FAIL (RED) because the `onNewMessage` function does not yet have `system_screenshot` handling. The tests should exercise the existing handler and fail on missing behavior (no notification sent, no lastMessage update for the new type).

**IMPORTANT:** The Cloud Function test must match the existing test pattern in notifications.test.js — use the same mock structure for `initializeFirestore`, the same `onNewMessage` import pattern, and the same `setupMockDb` helper approach. Read notifications.test.js carefully before implementing.
  </action>
  <verify>
    <automated>cd functions && npx jest __tests__/triggers/screenshotNotification.test.js --verbose 2>&1 | tail -15</automated>
    <manual>Verify the test file exists with 3 tests. They should FAIL (RED) because onNewMessage does not handle system_screenshot yet.</manual>
  </verify>
  <done>screenshotNotification.test.js exists with 3 RED tests covering: push notification to snap sender, mute respect, and conversation metadata update. All tests fail because onNewMessage does not handle system_screenshot type yet.</done>
</task>

</tasks>

<verification>
1. `__tests__/setup/jest.setup.js` contains expo-screen-capture mock with addScreenshotListener
2. `__tests__/services/screenshotService.test.js` exists with 5 test cases covering SCRN-02 and SCRN-03
3. `functions/__tests__/triggers/screenshotNotification.test.js` exists with 3 test cases covering SCRN-01
4. Smoke test still passes: `npx jest __tests__/services/smoke.test.js --verbose`
5. Screenshot service tests FAIL (RED): `npx jest __tests__/services/screenshotService.test.js` exits non-zero
6. Notification tests FAIL (RED): `cd functions && npx jest __tests__/triggers/screenshotNotification.test.js` exits non-zero
</verification>

<success_criteria>
- expo-screen-capture mock is available globally in test environment
- screenshotService.test.js has 5 RED tests: screenshottedAt write, system message creation, idempotency, non-snap skip, error handling
- screenshotNotification.test.js has 3 RED tests: push to sender, mute respect, conversation metadata
- Existing smoke tests still pass (mock addition does not break anything)
- All new tests fail with module-not-found or assertion errors (RED state, not syntax errors)
</success_criteria>

<output>
After completion, create `.planning/phases/08-screenshot-detection/08-00-SUMMARY.md`
</output>
