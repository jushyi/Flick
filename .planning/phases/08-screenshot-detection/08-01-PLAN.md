---
phase: 08-screenshot-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/firebase/screenshotService.js
  - src/services/screenshotQueueService.js
  - functions/index.js
  - src/services/firebase/notificationService.js
  - package.json
autonomous: true
requirements:
  - SCRN-01
  - SCRN-03

must_haves:
  truths:
    - "Screenshot event writes screenshottedAt timestamp on the snap message document"
    - "Screenshot event creates a system_screenshot message in the conversation messages subcollection"
    - "Only the first screenshot of a given snap triggers writes (idempotent)"
    - "Failed screenshot writes are queued locally and retried when connectivity returns"
    - "Cloud Function sends push notification to snap sender (not screenshotter) for system_screenshot messages"
    - "Cloud Function updates conversation metadata (lastMessage, updatedAt) for system_screenshot messages"
  artifacts:
    - path: "src/services/firebase/screenshotService.js"
      provides: "Firestore writes for screenshot events (screenshottedAt + system message)"
      exports: ["recordScreenshot"]
    - path: "src/services/screenshotQueueService.js"
      provides: "Offline queue for screenshot events using AsyncStorage"
      exports: ["queueScreenshotEvent", "processScreenshotQueue"]
    - path: "functions/index.js"
      provides: "onNewMessage handling for system_screenshot message type"
      contains: "system_screenshot"
    - path: "src/services/firebase/notificationService.js"
      provides: "Screenshot notification deep-link handler"
      contains: "screenshot"
  key_links:
    - from: "src/services/firebase/screenshotService.js"
      to: "conversations/{id}/messages/{id}"
      via: "updateDoc + addDoc"
      pattern: "updateDoc.*screenshottedAt"
    - from: "src/services/screenshotQueueService.js"
      to: "src/services/firebase/screenshotService.js"
      via: "processScreenshotQueue calls recordScreenshot"
      pattern: "recordScreenshot"
    - from: "functions/index.js"
      to: "notifications/sender.js"
      via: "sendPushNotification for system_screenshot type"
      pattern: "system_screenshot.*sendPushNotification"
---

<objective>
Install expo-screen-capture, create the screenshot service layer (Firestore writes + offline queue), and extend the Cloud Function to handle screenshot system messages with push notifications.

Purpose: Establishes the complete data pipeline for screenshot detection — from client-side recording to server-side notification delivery — before the UI integration layer connects it.
Output: screenshotService.js, screenshotQueueService.js, extended onNewMessage Cloud Function, notification deep-link handler for screenshot type.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-screenshot-detection/08-CONTEXT.md
@.planning/phases/08-screenshot-detection/08-RESEARCH.md
@src/services/firebase/messageService.js
@src/services/firebase/snapService.js
@src/services/uploadQueueService.js
@src/services/firebase/notificationService.js
@functions/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install expo-screen-capture and create screenshotService + screenshotQueueService</name>
  <files>
    package.json
    src/services/firebase/screenshotService.js
    src/services/screenshotQueueService.js
  </files>
  <action>
**Step 1: Install expo-screen-capture**
Run `npx expo install expo-screen-capture`. This is a native module — remind user a new EAS build is required before deployment.

**Step 2: Create `src/services/firebase/screenshotService.js`**

Export a single function `recordScreenshot({ conversationId, snapMessageId, screenshotterId, screenshotterName })` that:

1. Gets a reference to the snap message document: `conversations/{conversationId}/messages/{snapMessageId}`
2. Reads the snap document via `getDoc`
3. **Idempotency check**: If `snapData.screenshottedAt` already exists, return `{ success: true, alreadyScreenshotted: true }` — do NOT create duplicate system messages
4. **Active snap check**: If `snapData.type !== 'snap'` or snap is expired/deleted, return early with `{ success: true, skipped: true }`
5. Writes `screenshottedAt: serverTimestamp()` via `updateDoc` on the snap message document
6. Creates a system message document in `conversations/{conversationId}/messages/` via `addDoc` with this structure:
   ```js
   {
     senderId: screenshotterId,  // Use screenshotter's ID (NOT null) so onNewMessage can derive recipientId correctly
     type: 'system_screenshot',
     text: `${screenshotterName} screenshotted a snap`,
     screenshotterId: screenshotterId,
     snapMessageId: snapMessageId,
     gifUrl: null,
     imageUrl: null,
     createdAt: serverTimestamp(),
   }
   ```
   **IMPORTANT**: Set `senderId` to the screenshotter's ID. The `onNewMessage` Cloud Function uses `senderId` to derive `recipientId` (the snap sender who should receive the notification). If `senderId` were null, the function would crash. The `type: 'system_screenshot'` field signals this is a system message for rendering purposes.
7. Return `{ success: true, systemMessageId: <new doc id> }`
8. Wrap in try/catch, return `{ success: false, error: error.message }` on failure

Follow project service patterns: import from `@react-native-firebase/firestore`, use logger for all log statements, use `{ success, error }` return pattern.

**Step 3: Create `src/services/screenshotQueueService.js`**

Mirror the `uploadQueueService.js` pattern. This service handles offline screenshot event persistence.

Constants:
- `QUEUE_STORAGE_KEY = '@screenshotQueue'`
- `MAX_RETRIES = 3`

Export three functions:

1. `queueScreenshotEvent(event)` — Takes `{ conversationId, snapMessageId, screenshotterId, screenshotterName }`, appends to AsyncStorage array, returns `{ success: true }`

2. `processScreenshotQueue()` — Reads queue from AsyncStorage, iterates through events, calls `recordScreenshot` from screenshotService for each. On success, removes the event from the queue. On failure, increments a `retryCount` on the event. If `retryCount >= MAX_RETRIES`, remove the event and log a warning. Write updated queue back to AsyncStorage after processing.

3. `getQueueLength()` — Returns the current queue length (for debugging/logging).

Use `AsyncStorage` from `@react-native-async-storage/async-storage`. Use logger, not console.log.
  </action>
  <verify>
    <automated>npx jest --passWithNoTests --testPathPattern="screenshotService" 2>&1 | head -5 || echo "No tests yet — service files created"</automated>
    <manual>Verify screenshotService.js and screenshotQueueService.js exist with correct exports</manual>
  </verify>
  <done>screenshotService.js exports recordScreenshot with idempotent check-then-write pattern. screenshotQueueService.js exports queueScreenshotEvent, processScreenshotQueue, getQueueLength with AsyncStorage persistence. expo-screen-capture is installed in package.json.</done>
</task>

<task type="auto">
  <name>Task 2: Extend onNewMessage Cloud Function for system_screenshot + add notification deep-link</name>
  <files>
    functions/index.js
    src/services/firebase/notificationService.js
  </files>
  <action>
**Step 1: Extend `onNewMessage` in `functions/index.js`**

The `onNewMessage` Cloud Function handles conversation metadata updates and push notifications for all message types. Add handling for `system_screenshot` type:

1. **After the reaction handling block** (around line 2976), add a new block for `system_screenshot`:

```js
if (messageType === 'system_screenshot') {
  // System messages: update lastMessage but do NOT increment unread count
  // (system events are informational, not actionable unread messages)
  shouldIncrementUnread = false;
}
```

2. **In the lastMessage preview builder** (around line 2980), add a case for `system_screenshot`:
   - `lastMessagePreview` should be the message text (e.g., "Alex screenshotted a snap") — just use `message.text`
   - Add this as a case before the fallback: `messageType === 'system_screenshot' ? message.text : ...`

3. **In the push notification section** (around line 3068), add handling for `system_screenshot`:
   - Build notification body: `"${senderName} screenshotted your snap"` — the neutral/factual tone per user decision
   - **CRITICAL RECIPIENT LOGIC**: For system_screenshot, the `senderId` on the document is the screenshotter. The `recipientId` (derived from conversation ID) is the snap sender who should receive the notification. This is correct — the existing `recipientId` derivation already gives us the right person.
   - Set notification data type to `'screenshot'` (for client-side deep-link routing)
   - Include `conversationId` and `senderId` (screenshotter) in notification data

4. **Notification preference check**: The existing `dmEnabled` check already covers screenshot notifications per user decision ("Respects existing notification mute settings"). No additional preference needed.

5. **Do NOT add streak updates** for system_screenshot messages — only snap messages trigger streaks.

**Step 2: Add screenshot notification deep-link in `notificationService.js`**

In the `handleNotificationTapped` function's switch statement, add a `case 'screenshot':` block (before `default`) that navigates to the Conversation screen:

```js
case 'screenshot':
  return {
    success: true,
    data: {
      type: 'screenshot',
      screen: 'Conversation',
      params: {
        conversationId: conversationId,
        friendId: senderId,
        friendProfile: {
          uid: senderId,
          displayName: senderName || 'Unknown',
          photoURL: senderProfilePhotoURL || null,
        },
      },
    },
  };
```

This matches the existing `direct_message` case pattern. The `senderId` in the notification data is the screenshotter — when the snap sender taps the notification, they navigate to the conversation with the screenshotter (their friend).
  </action>
  <verify>
    <automated>cd functions && node -e "require('./index.js'); console.log('Cloud Functions loaded successfully')" 2>&1 | head -5 || echo "Functions syntax check"</automated>
    <manual>Verify onNewMessage handles system_screenshot type: updates lastMessage, sends push to recipient, does not increment unread</manual>
  </verify>
  <done>onNewMessage Cloud Function handles system_screenshot messages: updates conversation metadata (lastMessage with message text, updatedAt), sends push notification with "screenshotted your snap" body to snap sender only, does NOT increment unread count. notificationService.js handles screenshot notification taps with deep-link to Conversation screen.</done>
</task>

</tasks>

<verification>
1. `src/services/firebase/screenshotService.js` exists with `recordScreenshot` export that writes `screenshottedAt` + system message
2. `src/services/screenshotQueueService.js` exists with `queueScreenshotEvent`, `processScreenshotQueue`, `getQueueLength` exports
3. `expo-screen-capture` appears in package.json dependencies
4. `functions/index.js` handles `system_screenshot` message type in `onNewMessage`
5. `src/services/firebase/notificationService.js` has `screenshot` case in `handleNotificationTapped`
6. No lint errors: `npm run lint -- --quiet`
</verification>

<success_criteria>
- Screenshot events can be recorded to Firestore (screenshottedAt + system message) via screenshotService
- Failed screenshot writes are queued and retried via screenshotQueueService
- Cloud Function delivers push notification to snap sender when system_screenshot message is created
- Screenshot notification tap deep-links to conversation
- Idempotency: only first screenshot of a snap triggers the full flow
</success_criteria>

<output>
After completion, create `.planning/phases/08-screenshot-detection/08-01-SUMMARY.md`
</output>
