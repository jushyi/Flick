---
phase: 01-message-infrastructure-read-receipts
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - __tests__/components/ReadReceiptIndicator.test.js
  - __tests__/components/ConversationRow.test.js
  - __tests__/screens/SettingsScreen.test.js
  - src/components/ReadReceiptIndicator.js
  - src/components/index.js
  - src/screens/ConversationScreen.js
  - src/components/ConversationRow.js
  - src/hooks/useMessages.js
  - src/screens/SettingsScreen.js
  - src/context/AuthContext.js
autonomous: true
requirements:
  - READ-01
  - READ-03

must_haves:
  truths:
    - "Sender sees 'Delivered' below their last sent message when recipient has not opened the conversation"
    - "Sender sees 'Read [time]' below their last sent message when recipient has opened the conversation"
    - 'Read indicator updates in real-time without page refresh (recipient opens conversation -> sender sees Read appear)'
    - "Conversation list shows 'Sent' for own unread text messages, 'Seen' for own read text messages"
    - 'Conversation list shows unread count badge (cyan circle with white number) instead of plain dot'
    - 'Privacy toggle in Settings hides read status for both parties when either user has receipts off'
    - 'Delivered fades in after message bubble lands; Delivered->Read transition uses subtle crossfade'
  artifacts:
    - path: '__tests__/components/ReadReceiptIndicator.test.js'
      provides: 'Tests for ReadReceiptIndicator display logic, privacy gating, and props'
      contains: 'ReadReceiptIndicator'
    - path: '__tests__/components/ConversationRow.test.js'
      provides: 'Tests for getPreviewText status logic and UnreadBadge rendering'
      contains: 'ConversationRow'
    - path: '__tests__/screens/SettingsScreen.test.js'
      provides: 'Tests for Read Receipts toggle item presence and toggle behavior'
      contains: 'readReceipts'
    - path: 'src/components/ReadReceiptIndicator.js'
      provides: 'Delivered / Read [time] text component with fade animations'
      contains: 'ReadReceiptIndicator'
    - path: 'src/screens/ConversationScreen.js'
      provides: "ReadReceiptIndicator rendered below sender's last message"
      contains: 'ReadReceiptIndicator'
    - path: 'src/components/ConversationRow.js'
      provides: 'Status preview text (Sent/Seen) + unread count badge'
      contains: 'UnreadBadge'
    - path: 'src/screens/SettingsScreen.js'
      provides: 'Read Receipts privacy toggle'
      contains: 'readReceiptsEnabled'
  key_links:
    - from: 'src/screens/ConversationScreen.js'
      to: 'src/hooks/useConversation.js'
      via: 'Reads conversationDoc.readReceipts from hook return value'
      pattern: 'conversationDoc.*readReceipts'
    - from: 'src/components/ConversationRow.js'
      to: 'conversation.readReceipts'
      via: 'Derives Sent/Seen status from readReceipts timestamp comparison'
      pattern: 'readReceipts.*toMillis'
    - from: 'src/components/ConversationRow.js'
      to: 'src/context/AuthContext.js'
      via: 'Reads currentUserProfile.readReceiptsEnabled from useAuth() for privacy gate'
      pattern: 'useAuth.*readReceiptsEnabled'
    - from: 'src/screens/ConversationScreen.js'
      to: 'src/components/ReadReceiptIndicator.js'
      via: 'Passes isRead, readAt, visible props'
      pattern: 'ReadReceiptIndicator'
    - from: 'src/screens/SettingsScreen.js'
      to: 'Firestore users collection'
      via: 'Writes readReceiptsEnabled field to user profile'
      pattern: 'readReceiptsEnabled'
---

<objective>
Build the read receipt UI: create the ReadReceiptIndicator component with fade animations, integrate it into ConversationScreen below the sender's last message, update ConversationRow with status preview text (Sent/Seen) and unread count badge, and add the read receipts privacy toggle to Settings. This delivers the user-visible read receipt experience.

Purpose: This plan delivers the user-facing features. Sender sees "Delivered" then "Read [time]" below their last message. Conversation list shows contextual status words. Privacy toggle gives users control. These are the touchpoints users interact with.

Output: ReadReceiptIndicator component, updated ConversationScreen, updated ConversationRow, updated SettingsScreen with privacy toggle.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-message-infrastructure-read-receipts/01-CONTEXT.md
@.planning/phases/01-message-infrastructure-read-receipts/01-RESEARCH.md
@.planning/phases/01-message-infrastructure-read-receipts/01-01-SUMMARY.md
@src/screens/ConversationScreen.js
@src/components/ConversationRow.js
@src/components/MessageBubble.js
@src/screens/SettingsScreen.js
@src/components/index.js
@src/context/AuthContext.js
@src/constants/colors.js
@src/constants/typography.js
@src/constants/spacing.js
@src/constants/animations.js
@src/hooks/useMessages.js
@__tests__/setup/jest.setup.js
@__tests__/setup/testFactories.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test scaffolds for ReadReceiptIndicator, ConversationRow, and SettingsScreen</name>
  <files>
    __tests__/components/ReadReceiptIndicator.test.js
    __tests__/components/ConversationRow.test.js
    __tests__/screens/SettingsScreen.test.js
  </files>
  <action>
**ReadReceiptIndicator tests (`__tests__/components/ReadReceiptIndicator.test.js`):**

1. Create the test file. Follow the project's existing test patterns: mock functions defined OUTSIDE `jest.mock()`, referenced inside, `require()` for imports after mocks, `jest.clearAllMocks()` in `beforeEach`.
2. Mock `react-native` Animated API (use the existing RN mock from jest.setup.js; if Animated is not fully mocked, add minimal mock for `Animated.Value`, `Animated.timing`, `Animated.sequence`).
3. Mock `date-fns` `format` function to return a deterministic string (e.g., `jest.fn(() => '2:45 PM')`).
4. Write these test cases in a `describe('ReadReceiptIndicator')` block:
   - `it('renders "Delivered" when isRead is false')` -- render with `isRead={false}`, `visible={true}`, assert text "Delivered" is present.
   - `it('renders "Read [time]" when isRead is true and readAt is provided')` -- render with `isRead={true}`, `readAt={{ toDate: () => new Date() }}`, `visible={true}`, assert text contains "Read" and the formatted time.
   - `it('renders nothing visible when visible is false')` -- render with `visible={false}`, assert the component has opacity 0 or is not rendered.
   - `it('shows "Delivered" permanently when isRead is true but visible is false')` -- edge case: even if read data exists, invisible indicator stays hidden.
5. Use `@testing-library/react-native` `render` and `screen` for rendering and assertions (follow existing component test patterns).

**ConversationRow tests (`__tests__/components/ConversationRow.test.js`):**

6. Create the test file. Follow the same mock patterns as above.
7. Mock `expo-image` (if not already globally mocked in jest.setup.js, add `jest.mock('expo-image', () => ({ Image: 'Image' }))`).
8. Mock `date-fns` `isYesterday` and `format` functions.
9. Create factory helpers for test data:
   - `makeConversation({ lastMessage, readReceipts, unreadCount, ... })` -- returns a conversation object with sensible defaults.
   - `makeFriendProfile({ readReceiptsEnabled, ... })` -- returns a friend profile with sensible defaults.
10. Write these test cases in a `describe('ConversationRow')` block:

    **getPreviewText tests:**

- `it('shows "Sent" when current user sent last text message and friend has not read')` -- conversation with no `readReceipts` for friend, `lastMessage.senderId === currentUserId`, assert "Sent".
- `it('shows "Seen" when current user sent last text message and friend has read')` -- conversation with `readReceipts[friendId]` timestamp >= `lastMessage.timestamp`, assert "Seen".
- `it('shows "Sent" (not "Seen") when either user has readReceiptsEnabled === false')` -- Mock AuthContext `userProfile.readReceiptsEnabled = false` OR set `friendProfile.readReceiptsEnabled = false`, friend has read, assert "Sent".
- `it('shows actual message text when friend sent the last text message')` -- `lastMessage.senderId !== currentUserId`, `lastMessage.text = 'hello'`, assert "hello".
- `it('shows "Sent a GIF" when friend sent a gif')` -- `lastMessage.type = 'gif'`, `lastMessage.senderId !== currentUserId`, assert "Sent a GIF".
- `it('defaults type to text when type field is missing')` -- `lastMessage` with no `type` field, `senderId === currentUserId`, no readReceipt, assert "Sent".

**UnreadBadge tests:**

- `it('shows unread count number when unreadCount > 0')` -- `unreadCount: { [currentUserId]: 3 }`, assert "3" is rendered.
- `it('shows "99+" when unread count exceeds 99')` -- `unreadCount: { [currentUserId]: 150 }`, assert "99+" is rendered.
- `it('does not render badge when unreadCount is 0')` -- `unreadCount: { [currentUserId]: 0 }`, assert no badge text rendered.

**SettingsScreen tests (`__tests__/screens/SettingsScreen.test.js`):**

12. Create the test file. Follow the same mock patterns (mocks outside `jest.mock()`, `require()` after mocks, `clearAllMocks` in `beforeEach`).
13. Mock `AuthContext` to provide a `userProfile` with configurable `readReceiptsEnabled` field and an `updateProfile` function.
14. Mock `Alert` from `react-native` to capture `.alert()` calls.
15. Mock Firestore (`updateDoc`, `doc`, `getFirestore`) as jest.fn() stubs.
16. Write these test cases in a `describe('SettingsScreen - Read Receipts')` block:
    - `it('renders a "Read Receipts" toggle item in the Privacy section')` -- render SettingsScreen, assert text "Read Receipts" is present.
    - `it('shows toggle in ON state when readReceiptsEnabled is undefined (default)')` -- `userProfile.readReceiptsEnabled` is undefined, assert toggle value is true/on.
    - `it('shows toggle in OFF state when readReceiptsEnabled is false')` -- `userProfile.readReceiptsEnabled = false`, assert toggle value is false/off.
    - `it('shows confirmation Alert when toggling OFF')` -- simulate toggling from ON to OFF, assert `Alert.alert` was called with explanation text containing "you also won't see".
    - `it('writes readReceiptsEnabled to Firestore on toggle confirm')` -- simulate toggling OFF and confirming, assert `updateDoc` was called with `readReceiptsEnabled: false`.
    - `it('toggles ON without confirmation dialog')` -- `userProfile.readReceiptsEnabled = false`, simulate toggle ON, assert `updateDoc` called with `readReceiptsEnabled: true` without `Alert.alert`.

17. NOTE: These tests will initially FAIL (RED state) because the implementation doesn't exist yet. That is expected. Tasks 2, 3, and 4 will make them pass.
    </action>
    <verify>
    <automated>npx jest **tests**/components/ReadReceiptIndicator.test.js **tests**/components/ConversationRow.test.js **tests**/screens/SettingsScreen.test.js --no-coverage 2>&1 | tail -10</automated>
    <manual>Verify test files exist and Jest can parse them. Some tests may fail (RED) because the implementation doesn't exist yet -- that is expected at this stage. The key requirement is that the test files load without syntax errors and Jest recognizes all test cases.</manual>
    </verify>
    <done> - **tests**/components/ReadReceiptIndicator.test.js exists with 4+ test cases covering Delivered/Read display, visibility, and edge cases - **tests**/components/ConversationRow.test.js exists with 9+ test cases covering getPreviewText (Sent/Seen/privacy/friend messages/GIF/type defaults) and UnreadBadge (count display/99+ cap/zero count) - **tests**/screens/SettingsScreen.test.js exists with 6+ test cases covering Read Receipts toggle presence, default ON state, OFF state, Alert on toggle OFF, Firestore write, and toggle ON without Alert - Test files follow project mock conventions (mocks outside jest.mock, require after mocks, clearAllMocks) - Jest can parse all three files without errors
    </done>
    </task>

<task type="auto">
  <name>Task 2: Create ReadReceiptIndicator component and integrate into ConversationScreen</name>
  <files>
    src/components/ReadReceiptIndicator.js
    src/components/index.js
    src/screens/ConversationScreen.js
  </files>
  <action>
**ReadReceiptIndicator component (READ-01):**

1. Create `src/components/ReadReceiptIndicator.js`. This component renders "Delivered" or "Read [time]" below the sender's last sent message.
2. Props: `isRead` (boolean), `readAt` (Firestore Timestamp or null), `visible` (boolean - controls entrance animation).
3. Display logic:
   - When `isRead === true` and `readAt` exists: show `"Read {format(readAt.toDate(), 'h:mm a')}"` using `date-fns` `format` function.
   - When `isRead === false`: show `"Delivered"`.
   - When `visible === false`: render nothing (or keep opacity at 0).
4. Styling per CONTEXT.md decisions:
   - Color: `#7B7B9E` (muted secondary color). Use `colors.text.secondary` if it matches, otherwise hardcode this exact value.
   - Font: Readable sans-serif body font (NOT pixel/retro font). Use the project's `typography.fontFamily.readable` or `SpaceMono_400Regular`.
   - Font size: ~10px (match existing timestamp styling in MessageBubble).
   - Alignment: `alignItems: 'flex-end'` (right-aligned, matching sent message alignment).
   - Spacing: `paddingHorizontal: 16`, `marginTop: 2`, `marginBottom: 4`.
5. Animations per CONTEXT.md decisions:
   - "Delivered" fades in when `visible` becomes true: `Animated.timing` with `duration: 250` (animations.duration.slow), `useNativeDriver: true`.
   - Crossfade when `isRead` changes from false to true: sequence of fade out (100ms) then fade in (150ms). Use `Animated.sequence` with two `Animated.timing` calls.
   - Use `useRef(new Animated.Value(0))` for opacity.
6. Use React Native core `Animated` API (NOT reanimated -- per research, RN core is sufficient for simple fades).
7. Import `format` from `date-fns`.

**Barrel export:**

8. Add `ReadReceiptIndicator` to `src/components/index.js` barrel export.

**ConversationScreen integration (READ-01 + READ-03):**

9. Open `src/screens/ConversationScreen.js`.
10. The hook `useConversation` now returns `conversationDoc` (from Plan 01). Destructure it from the hook return.
11. Derive read state:
    - Get the friend's userId (the other participant in the conversation).
    - `const friendReadAt = conversationDoc?.readReceipts?.[friendId]`
    - Find the current user's last sent message in the messages array: `const lastSentMessage = messages.find(m => m.senderId === currentUserId)`
    - Determine if read: `const isRead = friendReadAt && lastSentMessage?.createdAt && friendReadAt.toMillis() >= lastSentMessage.createdAt.toMillis()`
12. **Privacy check:** Both users must have `readReceiptsEnabled !== false` for read status to show.
    - Current user's setting: `currentUserProfile?.readReceiptsEnabled !== false` (default ON).
    - Friend's setting: Get from friend profile data (passed via route params or available from useMessages hook). Check: `friendProfile?.readReceiptsEnabled !== false`.
    - `const showReadStatus = senderEnabled && recipientEnabled`.
    - When `showReadStatus` is false, the indicator should show "Delivered" permanently (never "Read").
13. Render `<ReadReceiptIndicator>` below the last sent message in the message list.
    - The indicator appears ONLY below the current user's most recent sent message (not every message).
    - Position it after the last sent message bubble in the FlatList renderItem or as a separate element.
    - `visible` prop: true once the message is confirmed sent (appears in messages list).
    - `isRead` prop: `showReadStatus && isRead`.
    - `readAt` prop: `friendReadAt`.
14. Handle the case where the user hasn't sent any messages yet: don't render the indicator.
    </action>
    <verify>
    <automated>npx jest **tests**/components/ReadReceiptIndicator.test.js --no-coverage 2>&1 | tail -5</automated>
    <manual>Visually verify in the app: send a message, see "Delivered" fade in. Have friend open conversation, see "Delivered" transition to "Read [time]" with crossfade animation.</manual>
    </verify>
    <done> - ReadReceiptIndicator component renders "Delivered" or "Read [time]" with correct styling (#7B7B9E, ~10px, sans-serif, right-aligned) - Fade-in animation on "Delivered" appearance (250ms) - Crossfade animation on Delivered -> Read transition (100ms out + 150ms in) - ConversationScreen derives read state from conversationDoc.readReceipts - Indicator appears only below sender's most recent sent message - Privacy check: both users must have readReceiptsEnabled for "Read" to show - Exported from components/index.js barrel - ReadReceiptIndicator tests pass
    </done>
    </task>

<task type="auto">
  <name>Task 3: Update ConversationRow with status preview text and unread count badge</name>
  <files>
    src/components/ConversationRow.js
    src/hooks/useMessages.js
  </files>
  <action>
**Prerequisite: Extend friendProfile cache in useMessages (data dependency for privacy check):**

1. Open `src/hooks/useMessages.js`. Find the `fetchFriendProfiles` function (around line 46).
2. The current cache stores only `uid`, `username`, `displayName`, `profilePhotoURL`, `nameColor` for each friend. Add `readReceiptsEnabled` to the cached fields:
   ```javascript
   cache.set(id, {
     uid: id,
     username: data.username || 'unknown',
     displayName: data.displayName || 'Unknown User',
     profilePhotoURL: data.profilePhotoURL || data.photoURL || null,
     nameColor: data.nameColor || null,
     readReceiptsEnabled: data.readReceiptsEnabled, // undefined treated as true via !== false
   });
   ```
3. This ensures ConversationRow receives `friendProfile.readReceiptsEnabled` via the existing `friendProfile` prop (passed as `item.friendProfile` from MessagesScreen's `renderConversation`). No prop interface or parent call site changes needed -- the data flows through the existing `friendProfile` prop automatically.

**Status preview text (READ-01 conversation list view):**

4. Open `src/components/ConversationRow.js`.
5. The component already receives `friendProfile` as a prop (line 28: `({ conversation, friendProfile, currentUserId, onPress, onLongPress })`). After step 1-3 above, `friendProfile.readReceiptsEnabled` is available.
6. Find where the last message preview text is rendered (the subtitle/secondary text below the friend's name). The existing `getPreviewText()` function is at line 33.
7. Replace the current `getPreviewText()` logic with a new implementation that uses the Snapchat-style status words per CONTEXT.md:
   - Derive `friendId` from conversation participants: `const friendId = conversation.participants?.find(p => p !== currentUserId)`.
   - **When current user sent the last message** (`lastMessage.senderId === currentUserId`):
     - Determine if friend has read it: compare `conversation.readReceipts?.[friendId]` timestamp against `lastMessage.timestamp`. If `readReceipts[friendId].toMillis() >= lastMessage.timestamp.toMillis()`, it's read.
     - **Privacy gate:** Import `useAuth` from `AuthContext` inside ConversationRow to access the current user's profile directly: `const { userProfile: currentUserProfile } = useAuth();`. Then: `const showReadStatus = currentUserProfile?.readReceiptsEnabled !== false && friendProfile?.readReceiptsEnabled !== false`. This avoids adding a new prop and avoids modifying MessagesScreen. AuthContext is a global context already available throughout the app.
     - Text messages (`type === 'text'` or missing type): "Seen" if read AND showReadStatus, "Sent" if unread or privacy off.
     - GIF messages (`type === 'gif'`): "Seen" if read AND showReadStatus, "Sent" if unread or privacy off.
     - Future types (snap, reaction, reply, tagged_photo): add placeholders now for forward compatibility:
       - `type === 'snap'`: "Opened" if read, "Delivered" if unread.
       - `type === 'reaction'`: "Seen" if read, "Sent" if unread.
       - `type === 'tagged_photo'`: "Seen" if read, "Sent" if unread.
       - Default fallback: "Sent".
   - **When friend sent the last message** (`lastMessage.senderId !== currentUserId`):
     - `type === 'text'` or missing: show `lastMessage.text` (existing behavior).
     - `type === 'gif'`: show "Sent a GIF" (existing behavior, keep it).
     - `type === 'snap'`: show "Sent you a snap" (placeholder for Phase 3).
     - `type === 'reaction'`: show `"Reacted ${lastMessage.emoji} to your message"` (placeholder for Phase 2).
     - `type === 'tagged_photo'`: show "Tagged you in a photo" (placeholder for Phase 5).
     - Default: show `lastMessage.text || 'No messages yet'`.
8. Handle the `lastMessage?.type` field gracefully: default to `'text'` when missing (`const msgType = lastMessage?.type || 'text'`).
9. Conversation list status transitions should be instant (no animation per CONTEXT.md).

**Unread count badge (READ-01 conversation list view):**

10. Find the existing unread indicator in ConversationRow. Per research, there's a simple 8x8 cyan dot (`unreadDot` style).
11. Replace the simple dot with an `UnreadBadge` sub-component:

- Shows when `unreadCount > 0` (where `unreadCount` comes from `conversation.unreadCount?.[currentUserId]` or is passed as a prop).
- Displays the count number: "1", "2", "3", etc.
- Cap at "99+" for counts above 99.
- Styling per CONTEXT.md + research:
  - `minWidth: 18`, `height: 18`, `borderRadius: 9` (circle).
  - `backgroundColor: '#00D4FF'` (cyan, `colors.interactive.primary`).
  - Text: `fontSize: 10`, `color: '#0A0A1A'` (dark on cyan, `colors.text.inverse` or `colors.background.primary`), bold font.
  - `paddingHorizontal: 4` (allows pill shape for 2+ digit numbers).
  - Position: same location as current `unreadDot` (in the right column of the row).

12. Remove or replace the old `unreadDot` style/component.
    </action>
    <verify>
    <automated>npx jest **tests**/components/ConversationRow.test.js --no-coverage 2>&1 | tail -5</automated>
    <manual>In the Messages tab: verify "Sent"/"Seen" status for own messages, actual text for friend's messages. Verify cyan count badge shows number instead of plain dot. Check "99+" cap.</manual>
    </verify>
    <done> - useMessages.js caches readReceiptsEnabled in friendProfile - ConversationRow shows "Sent"/"Seen" for own text/gif messages based on readReceipts - ConversationRow shows actual text for friend's text messages, "Sent a GIF" for friend's gifs - Forward-compatible preview text for snap, reaction, tagged_photo types - Privacy: "Sent" shown permanently when either user has receipts off (current user via useAuth() from AuthContext, friend via friendProfile.readReceiptsEnabled from useMessages cache) - No new props added to ConversationRow; no changes to MessagesScreen - Unread count badge replaces plain dot: cyan circle, white number, "99+" cap - Type field defaults to 'text' when missing (backward compatibility) - ConversationRow tests pass
    </done>
    </task>

<task type="auto">
  <name>Task 4: Add read receipts privacy toggle to Settings and user profile</name>
  <files>
    src/screens/SettingsScreen.js
    src/context/AuthContext.js
  </files>
  <action>
**Privacy toggle in Settings (READ-01 privacy):**

1. Open `src/screens/SettingsScreen.js`.
2. Find the "Privacy" section in the settings list (look for items like "Sync Contacts", "Blocked Users").
3. Add a new toggle item for "Read Receipts" in the Privacy section, positioned after "Sync Contacts" and before "Blocked Users" (or at a natural position in the Privacy section):
   ```
   {
     id: 'readReceipts',
     label: 'Read Receipts',
     icon: 'eye-outline',  // or appropriate icon from the icon set used in Settings
     isToggle: true,
     value: userProfile?.readReceiptsEnabled !== false,  // Default ON for existing users
     onToggle: handleReadReceiptsToggle,
     subtitle: "When off, you won't send or receive read receipts",
   }
   ```
4. Implement `handleReadReceiptsToggle`:
   - When user toggles OFF: show an Alert with explanation: "When you turn off read receipts, you also won't see when others read your messages." with "Turn Off" and "Cancel" buttons.
   - On confirm: write `readReceiptsEnabled: false` to the user's Firestore profile document.
   - When user toggles ON: write `readReceiptsEnabled: true` directly (no confirmation needed).
   - Use `updateDoc(doc(db, 'users', user.uid), { readReceiptsEnabled: newValue })`.
   - Also update the local profile state via `updateUserProfile` or `updateProfile` from AuthContext so the UI reflects the change immediately without waiting for Firestore sync.
5. Import `Alert` from 'react-native' if not already imported.
6. Import Firestore operations (`doc`, `updateDoc`, `getFirestore`) if not already imported.

**AuthContext update (if needed):**

7. Open `src/context/AuthContext.js`. Check if `updateProfile` or `updateUserProfile` already handles arbitrary profile field updates.
8. If `updateProfile` only updates specific fields (like displayName, photoURL), extend it to handle the `readReceiptsEnabled` field. Or if there's a generic `updateProfile` that writes to Firestore and updates local state, it should work as-is.
9. Ensure the local `userProfile` state in AuthContext includes `readReceiptsEnabled` when it's loaded from Firestore (it should come automatically since the profile document is loaded in full).
10. The `readReceiptsEnabled` field defaults to `undefined` for existing users (which is treated as `true` via `!== false` checks throughout the codebase). No migration needed.

**IMPORTANT:** The toggle uses the PixelToggle component (existing retro-styled toggle). Do NOT build a custom toggle. Use whatever toggle pattern the Settings screen already uses for existing toggles (like notification settings).
</action>
<verify>
<automated>npx jest **tests**/screens/SettingsScreen.test.js --no-coverage 2>&1 | tail -5</automated>
<manual>In Settings > Privacy section: verify "Read Receipts" toggle is visible, defaults to ON. Toggle OFF, see confirmation Alert with explanation. Toggle back ON. Verify the change persists across app restarts.</manual>
</verify>
<done> - "Read Receipts" toggle appears in Privacy section of Settings - Toggle defaults to ON for existing users (readReceiptsEnabled undefined treated as true) - Toggling OFF shows Alert with explanation text - Toggle writes readReceiptsEnabled to user's Firestore profile - Local profile state updates immediately on toggle - Uses existing PixelToggle component (not custom) - Subtitle text: "When off, you won't send or receive read receipts"
</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run lint` -- no linting errors
2. `npx jest --no-coverage` -- full test suite passes
3. Visual verification in app:
   a. Send a message in conversation -- "Delivered" fades in below last sent message
   b. Recipient opens conversation -- sender sees "Read [time]" appear with crossfade
   c. Conversation list shows "Sent" for unread own messages, "Seen" for read own messages
   d. Conversation list shows cyan count badge with number instead of plain dot
   e. Settings > Privacy shows "Read Receipts" toggle, defaults to ON
   f. Toggle OFF shows confirmation Alert, hides read indicators for both parties
   g. "99+" shown for large unread counts
</verification>

<success_criteria>

- Sender sees "Delivered" then "Read [time]" below their most recent sent message (READ-01)
- Read indicator updates in real-time when recipient opens conversation (READ-03)
- Conversation list shows Sent/Seen status words for own messages
- Unread count badge (cyan circle, white number) replaces plain dot
- Privacy toggle in Settings controls read receipt visibility for both parties
- Animations: fade-in for Delivered, crossfade for Delivered->Read
- All styling matches CONTEXT.md specs (#7B7B9E, ~10px, sans-serif, right-aligned)
- Backward compatible: existing conversations without readReceipts show "Delivered"
  </success_criteria>

<output>
After completion, create `.planning/phases/01-message-infrastructure-read-receipts/01-02-SUMMARY.md`
</output>
