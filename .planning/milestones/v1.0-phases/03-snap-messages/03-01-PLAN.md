---
phase: 03-snap-messages
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/firebase/snapService.js
  - functions/index.js
  - __tests__/services/snapService.test.js
  - functions/__tests__/snapFunctions.test.js
autonomous: true
requirements:
  - SNAP-03
  - SNAP-06
  - SNAP-07
  - SNAP-08

must_haves:
  truths:
    - 'Snap photo uploads to snap-photos/ Storage path and creates a type:snap message document'
    - 'uploadAndSendSnap retries up to 3 times silently on network failure before returning error'
    - 'markSnapViewed writes viewedAt timestamp on the snap message document'
    - 'getSignedSnapUrl Cloud Function returns a 5-minute signed URL for snap-photos/ paths only'
    - 'onSnapViewed Cloud Function deletes the Storage file when viewedAt changes from null to a timestamp'
    - 'cleanupExpiredSnaps scheduled function deletes orphaned snaps past expiresAt'
    - 'onNewMessage handles type:snap for lastMessage preview and push notification'
  artifacts:
    - path: 'src/services/firebase/snapService.js'
      provides: 'uploadAndSendSnap, markSnapViewed, getSignedSnapUrl client functions'
      exports: ['uploadAndSendSnap', 'markSnapViewed', 'getSignedSnapUrl']
    - path: 'functions/index.js'
      provides: 'getSignedSnapUrl, onSnapViewed, cleanupExpiredSnaps Cloud Functions + snap handling in onNewMessage'
      contains: 'getSignedSnapUrl'
    - path: '__tests__/services/snapService.test.js'
      provides: 'Unit tests for snapService client functions'
    - path: 'functions/__tests__/snapFunctions.test.js'
      provides: 'Unit tests for snap Cloud Functions'
  key_links:
    - from: 'src/services/firebase/snapService.js'
      to: 'functions/index.js'
      via: 'httpsCallable for getSignedSnapUrl'
      pattern: 'httpsCallable.*getSignedSnapUrl'
    - from: 'src/services/firebase/snapService.js'
      to: 'snap-photos/ Storage path'
      via: 'storageRef.putFile for upload'
      pattern: 'snap-photos/'
    - from: 'functions/index.js (onSnapViewed)'
      to: 'Storage bucket'
      via: 'bucket.file(snapStoragePath).delete()'
      pattern: "file\\.delete"
---

<objective>
Build the snap service layer (client + Cloud Functions) that powers the entire snap lifecycle: upload, send, mark viewed, signed URL generation, and server-side cleanup.

Purpose: Every other snap plan depends on this service layer. It provides the data operations that the camera UI, viewer, and bubble components will call.
Output: snapService.js (client), 3 new Cloud Functions, extended onNewMessage, test files for both.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-snap-messages/03-RESEARCH.md

@src/services/firebase/messageService.js
@src/services/firebase/storageService.js
@src/services/firebase/signedUrlService.js
@functions/index.js
@**tests**/setup/jest.setup.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snapService.js client service + tests</name>
  <files>
    src/services/firebase/snapService.js
    __tests__/services/snapService.test.js
  </files>
  <action>
Create `src/services/firebase/snapService.js` following the existing service layer pattern (`{ success, error }` returns). The service exports three functions:

1. **`uploadAndSendSnap(conversationId, senderId, localUri, caption = null)`**
   - Compress image using `expo-image-manipulator` (same pattern as storageService `compressImage`)
   - Generate unique snapId: `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
   - Upload to `snap-photos/${senderId}/${snapId}.jpg` via `storageRef.putFile()` with `cacheControl: 'no-store'` and `contentType: 'image/jpeg'`
   - Calculate `expiresAt` as 48 hours from now using `Timestamp.fromDate()`
   - Create message document in `conversations/${conversationId}/messages/` with fields: `senderId`, `type: 'snap'`, `text: null`, `gifUrl: null`, `imageUrl: null`, `snapStoragePath`, `caption` (truncated to 150 chars or null), `viewedAt: null`, `expiresAt`, `createdAt: serverTimestamp()`
   - **Auto-retry logic (per locked user decision):** Wrap the upload+write sequence in a retry loop. On failure, retry up to 3 times with exponential backoff (delays: 1s, 2s, 4s). Log each retry attempt via logger.warn. If all 3 retries fail, return `{ success: false, error: error.message, retriesExhausted: true }` so the UI can show the tap-to-retry error state.
   - Return `{ success: true, messageId }` on success
   - Use logger throughout (never console.log)

2. **`markSnapViewed(conversationId, messageId)`**
   - Update the message document setting `viewedAt: serverTimestamp()`
   - Firestore rules already allow non-sender to update viewedAt (verified in research)
   - Return `{ success: true }` or `{ success: false, error }`

3. **`getSignedSnapUrl(snapStoragePath)`**
   - Call `httpsCallable(getFunctions(), 'getSignedSnapUrl')` with `{ snapStoragePath }`
   - Return `{ success: true, url }` or `{ success: false, error }`
   - Do NOT store the signed URL in Firestore -- always fetch on-demand

Import organization: React Native Firebase imports first, then expo packages, then internal utils.

Create `__tests__/services/snapService.test.js` following `messageService.test.js` test pattern:

- Mock Firebase modules at module scope (getStorage, getFirestore, getFunctions, httpsCallable)
- Mock expo-image-manipulator
- Test uploadAndSendSnap: verifies correct storage path, message doc fields, caption truncation at 150 chars, expiresAt calculation
- Test uploadAndSendSnap retry: simulate first 2 calls failing, 3rd succeeding -- verify 3 attempts made, success returned
- Test uploadAndSendSnap retry exhaustion: simulate all 3 calls failing -- verify `{ success: false, retriesExhausted: true }` returned
- Test markSnapViewed: verifies updateDoc called with serverTimestamp
- Test getSignedSnapUrl: verifies httpsCallable called with correct path, rejects non-snap-photos paths
- Test error handling: each function returns `{ success: false }` on error
  </action>
  <verify>
  <automated>cd "C:/Users/maser/Lapse Clone" && npx jest **tests**/services/snapService.test.js --no-coverage 2>&1 | tail -20</automated>
  </verify>
  <done>snapService.js exports uploadAndSendSnap, markSnapViewed, getSignedSnapUrl. uploadAndSendSnap includes auto-retry (3 attempts with backoff). All tests pass including retry scenarios. Functions follow project service pattern with { success, error } returns.</done>
  </task>

<task type="auto">
  <name>Task 2: Add snap Cloud Functions + extend onNewMessage + tests</name>
  <files>
    functions/index.js
    functions/__tests__/snapFunctions.test.js
  </files>
  <action>
Add three new Cloud Functions to `functions/index.js` and extend the existing `onNewMessage` function:

1. **`getSignedSnapUrl` (onCall)**
   - Authenticate caller (request.auth.uid required)
   - Validate `snapStoragePath` starts with `snap-photos/` (reject other paths)
   - Validate caller is a participant in the conversation (parse conversationId from request.data or validate via Firestore lookup)
   - Generate signed URL with `file.getSignedUrl({ version: 'v4', action: 'read', expires: Date.now() + 5 * 60 * 1000 })` -- 5-minute expiry
   - Check file exists first, throw `not-found` HttpsError if missing
   - Memory: 256MiB, timeout: 30s

2. **`onSnapViewed` (Firestore onUpdate trigger)**
   - Trigger: `conversations/{conversationId}/messages/{messageId}` onUpdate
   - Guard: only fire when `after.type === 'snap'` AND `before.viewedAt === null` AND `after.viewedAt !== null`
   - Read `snapStoragePath` from `after` data
   - Delete the Storage file via `bucket.file(snapStoragePath).delete()`
   - Wrap in try/catch -- log error but do not throw (cleanup is best-effort)
   - Memory: 256MB, timeout: 60s

3. **`cleanupExpiredSnaps` (scheduled, every 2 hours)**
   - Query all messages collection group where `type == 'snap'` AND `expiresAt <= now` AND `viewedAt == null`
   - For each: delete Storage file (if exists), then delete the Firestore message document
   - Limit to 100 per run to avoid timeout
   - Log count of cleaned up snaps
   - Memory: 512MB, timeout: 120s

4. **Extend `onNewMessage`**
   - In the existing `onNewMessage` Cloud Function, add a case for `type: 'snap'` in:
     - `lastMessage` preview: set `lastMessage.text` to null, `lastMessage.type` to `'snap'`
     - Push notification body: use randomized templates from array: `["sent you a snap", "New snap from {senderName}", "{senderName} just snapped you"]` (no emojis per user decision)
   - Snap messages SHOULD update `lastMessage` and `unreadCount` (unlike reaction messages which skip these)

Create `functions/__tests__/snapFunctions.test.js`:

- Test getSignedSnapUrl: auth validation, path validation (reject non-snap paths), signed URL generation
- Test onSnapViewed: guard conditions (type check, viewedAt transition), Storage deletion call
- Test cleanupExpiredSnaps: query construction, batch deletion, handles empty results
- Mock firebase-admin storage and firestore
  </action>
  <verify>
  <automated>cd "C:/Users/maser/Lapse Clone/functions" && npx jest **tests**/snapFunctions.test.js --no-coverage 2>&1 | tail -20</automated>
  </verify>
  <done>Three Cloud Functions added (getSignedSnapUrl, onSnapViewed, cleanupExpiredSnaps). onNewMessage handles type:snap for lastMessage preview and push notification. All Cloud Function tests pass.</done>
  </task>

</tasks>

<verification>
- `npx jest __tests__/services/snapService.test.js` passes
- `cd functions && npx jest __tests__/snapFunctions.test.js` passes
- snapService.js exports three functions following project service pattern
- uploadAndSendSnap includes retry logic (3 attempts, exponential backoff)
- functions/index.js has getSignedSnapUrl, onSnapViewed, cleanupExpiredSnaps exports
- onNewMessage handles type:snap messages
</verification>

<success_criteria>

- Complete snap service layer (client + server) with full test coverage
- uploadAndSendSnap creates correct Firestore document with all required fields
- uploadAndSendSnap retries silently up to 3 times on failure, returns retriesExhausted flag
- getSignedSnapUrl returns 5-minute expiry URLs for snap-photos/ paths only
- onSnapViewed deletes Storage file on viewedAt transition
- cleanupExpiredSnaps handles orphaned snaps
- onNewMessage generates snap push notifications with randomized templates
  </success_criteria>

<output>
After completion, create `.planning/phases/03-snap-messages/03-01-SUMMARY.md`
</output>
