---
phase: 02-message-interactions
plan: 06
type: execute
wave: 3
depends_on:
  - 02-02
  - 02-03
  - 02-04
  - 02-05
files_modified:
  - src/screens/ConversationScreen.js
  - src/components/DMInput.js
  - src/components/ConversationRow.js
autonomous: false
requirements:
  - REACT-01
  - REACT-02
  - REACT-03
  - REACT-04
  - REACT-05
  - REPLY-01
  - REPLY-02
  - REPLY-03
  - REPLY-04
  - DEL-01
  - DEL-02
  - DEL-03

must_haves:
  truths:
    - 'Double-tap a message adds heart reaction, long-press opens picker with 6 emojis'
    - 'Reactions display as emoji pills below the target message'
    - 'Swipe right on message activates reply mode with preview above input'
    - 'Reply sends message with quoted context that renders inline'
    - 'User can unsend own messages within 15 minutes; both users see deleted state'
    - 'User can delete-for-me any own message with pixel confirmation dialog'
    - 'Reaction notifications delivered to recipient with emoji'
    - 'Conversation list preview updates correctly for reactions (no preview change) and unsend (fallback)'
  artifacts:
    - path: 'src/screens/ConversationScreen.js'
      provides: 'Full integration of reactions, replies, deletion, action menu, and scroll-to-message'
      contains: 'useMessageActions'
    - path: 'src/components/DMInput.js'
      provides: 'Extended DMInput with ReplyPreview integration and reply send support'
      contains: 'ReplyPreview'
    - path: 'src/components/ConversationRow.js'
      provides: 'Updated conversation preview handling for unsent messages'
      contains: 'unsent'
  key_links:
    - from: 'src/screens/ConversationScreen.js'
      to: 'src/hooks/useMessageActions.js'
      via: 'useMessageActions hook provides all interaction state'
      pattern: 'useMessageActions'
    - from: 'src/screens/ConversationScreen.js'
      to: 'src/components/ReactionPicker.js'
      via: 'renders ReactionPicker overlay controlled by useMessageActions'
      pattern: 'ReactionPicker'
    - from: 'src/components/DMInput.js'
      to: 'src/components/ReplyPreview.js'
      via: 'renders ReplyPreview above input when replyToMessage is set'
      pattern: 'ReplyPreview'
    - from: 'src/screens/ConversationScreen.js'
      to: 'src/hooks/useConversation.js'
      via: 'consumes reactionMap and filtered messages'
      pattern: 'reactionMap'
---

<objective>
Wire all Phase 2 components together in ConversationScreen, extend DMInput for replies, update ConversationRow for unsent previews, and verify the complete interaction flow.

Purpose: Final integration plan that connects all the individual pieces (service layer, hooks, UI components) into a working feature. This is where users will actually experience reactions, replies, and deletion.
Output: Fully functional message interactions with visual verification checkpoint.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-message-interactions/02-CONTEXT.md
@.planning/phases/02-message-interactions/02-RESEARCH.md
@.planning/phases/02-message-interactions/02-01-SUMMARY.md
@.planning/phases/02-message-interactions/02-02-SUMMARY.md
@.planning/phases/02-message-interactions/02-03-SUMMARY.md
@.planning/phases/02-message-interactions/02-04-SUMMARY.md
@.planning/phases/02-message-interactions/02-05-SUMMARY.md
@src/screens/ConversationScreen.js
@src/components/DMInput.js
@src/components/ConversationRow.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate all interactions into ConversationScreen</name>
  <files>src/screens/ConversationScreen.js</files>
  <action>
Wire up all Phase 2 components and hooks into ConversationScreen.

**New imports:**

```javascript
import { GestureHandlerRootView } from 'react-native-gesture-handler';

import ReactionPicker from '../components/ReactionPicker';
import PixelConfirmDialog from '../components/PixelConfirmDialog';

import useMessageActions from '../hooks/useMessageActions';
```

**Hook integration:**

After the existing `useConversation` call, add useMessageActions:

```javascript
const {
  messages,
  reactionMap,
  handleSendReaction,
  handleRemoveReaction,
  handleSendReply,
  handleDeleteForMe,
  conversationDoc,
  sendMessage: sendMsg,
  loadMore,
  hasMore,
  loading,
} = useConversation(conversationId, user.uid, deletedAt);

const {
  actionMenuVisible,
  actionMenuMessage,
  actionMenuPosition,
  replyToMessage,
  openActionMenu,
  closeActionMenu,
  handleReaction,
  handleDoubleTapHeart,
  startReply,
  cancelReply,
  handleUnsend,
  handleDeleteForMe: triggerDeleteForMe,
} = useMessageActions({
  conversationId,
  currentUserId: user.uid,
  onSendReaction: handleSendReaction,
  onRemoveReaction: handleRemoveReaction,
  onSendReply: handleSendReply,
  onDeleteForMe: handleDeleteForMe,
  flatListRef,
});
```

**Delete confirmation dialog state:**

```javascript
const [deleteConfirmVisible, setDeleteConfirmVisible] = useState(false);
const [pendingDeleteMessageId, setPendingDeleteMessageId] = useState(null);
```

Wire `triggerDeleteForMe` to first show the PixelConfirmDialog, then on confirm call `handleDeleteForMe(pendingDeleteMessageId)`.

**Scroll-to-original-message:**
Add a function that uses `flatListRef` to scroll to the original message when a reply mini bubble is tapped:

```javascript
const scrollToMessage = useCallback(
  messageId => {
    const index = messages.findIndex(m => m.id === messageId);
    if (index !== -1 && flatListRef.current) {
      flatListRef.current.scrollToIndex({ index, animated: true, viewPosition: 0.5 });
      // Brief highlight: set a state `highlightedMessageId` for 1.5 seconds
      setHighlightedMessageId(messageId);
      setTimeout(() => setHighlightedMessageId(null), 1500);
    }
  },
  [messages]
);
```

Add `highlightedMessageId` state and pass to MessageBubble for a brief background flash effect.

**MessageBubble renderItem update:**
Update the FlatList renderItem to pass all new props to MessageBubble:

```javascript
const renderMessage = useCallback(({ item }) => {
  const isCurrentUser = item.senderId === user.uid;
  const messageReactions = reactionMap.get(item.id) || null;
  const canUnsend = isCurrentUser && item.createdAt &&
    (Date.now() - (item.createdAt.toDate ? item.createdAt.toDate() : new Date(item.createdAt)).getTime()) < 15 * 60 * 1000;

  return (
    <MessageBubble
      message={item}
      isCurrentUser={isCurrentUser}
      showTimestamp={/* existing logic */}
      onPress={/* existing toggle timestamp */}
      reactions={messageReactions}
      onDoubleTap={() => handleDoubleTapHeart(item.id)}
      onLongPress={(message, layout) => openActionMenu(message, layout)}
      onSwipeReply={() => startReply(item)}
      onReactionPress={(emoji) => handleReaction(emoji)}
      onScrollToMessage={scrollToMessage}
      replyTo={item.replyTo}
      currentUserId={user.uid}
      highlighted={highlightedMessageId === item.id}
    />
  );
}, [user.uid, reactionMap, handleDoubleTapHeart, openActionMenu, startReply, handleReaction, scrollToMessage, highlightedMessageId]);
```

**Send message with reply support:**
Modify the send handler to support replies:

```javascript
const handleSend = useCallback(
  async (text, gifUrl, imageUrl) => {
    if (replyToMessage) {
      await handleSendReply(text, gifUrl, imageUrl, replyToMessage);
      cancelReply();
    } else {
      await sendMsg(text, gifUrl, imageUrl);
    }
  },
  [replyToMessage, handleSendReply, cancelReply, sendMsg]
);
```

**Render ReactionPicker and PixelConfirmDialog:**
Add at the end of the component return, after the FlatList and DMInput:

```jsx
<ReactionPicker
  visible={actionMenuVisible}
  message={actionMenuMessage}
  position={actionMenuPosition}
  isCurrentUser={actionMenuMessage?.senderId === user.uid}
  canUnsend={/* check 15-min window on actionMenuMessage */}
  onReaction={(emoji) => handleReaction(emoji)}
  onReply={() => { startReply(actionMenuMessage); closeActionMenu(); }}
  onUnsend={() => { handleUnsend(actionMenuMessage.id); }}
  onDeleteForMe={() => {
    setPendingDeleteMessageId(actionMenuMessage.id);
    closeActionMenu();
    setDeleteConfirmVisible(true);
  }}
  onClose={closeActionMenu}
/>

<PixelConfirmDialog
  visible={deleteConfirmVisible}
  title="Delete Message"
  message="This will only remove it from your view. The other person can still see it."
  confirmText="Delete"
  cancelText="Cancel"
  destructive
  onConfirm={() => {
    triggerDeleteForMe(pendingDeleteMessageId);
    setDeleteConfirmVisible(false);
    setPendingDeleteMessageId(null);
  }}
  onCancel={() => {
    setDeleteConfirmVisible(false);
    setPendingDeleteMessageId(null);
  }}
/>
```

**Edge case handling:**

- If actionMenuMessage gets unsent while picker is open: the useConversation hook will update the message to \_isUnsent, and the ReactionPicker should detect `message._isUnsent` and auto-close (add this check in a useEffect watching actionMenuMessage).
- If replyToMessage gets unsent while composing: add a useEffect that watches the messages list and if replyToMessage.id is now \_isUnsent, clear replyToMessage but keep typed text.

**GestureHandlerRootView:**
Ensure the outermost View in ConversationScreen is wrapped in GestureHandlerRootView if not already present (required for gesture handlers to work inside modals/screens).
</action>
<verify>
<automated>npx jest --testPathPattern="**tests**/(hooks|services|components)" --bail 2>&1 | tail -10</automated>
<manual>Open a DM conversation, double-tap a message (heart reaction should appear), long-press (picker should open), swipe right (reply mode should activate)</manual>
</verify>
<done>ConversationScreen fully wired with useMessageActions, ReactionPicker overlay, PixelConfirmDialog, scroll-to-message, reply send support, and edge case handling</done>
</task>

<task type="auto">
  <name>Task 2: Extend DMInput with ReplyPreview and update ConversationRow for unsent</name>
  <files>src/components/DMInput.js, src/components/ConversationRow.js</files>
  <action>
**1. Extend DMInput with ReplyPreview:**

Add new props to DMInput:

- `replyToMessage` — message being replied to (or null)
- `replyToSenderName` — display name for reply preview
- `onCancelReply` — callback to clear reply mode

Import ReplyPreview:

```javascript
import ReplyPreview from './ReplyPreview';
```

Render ReplyPreview ABOVE the input area (between any top border and the input row):

```jsx
{
  replyToMessage && (
    <ReplyPreview
      message={replyToMessage}
      senderName={replyToSenderName}
      onCancel={onCancelReply}
    />
  );
}
```

When reply mode activates (replyToMessage changes from null to non-null), auto-focus the TextInput. Add a useEffect:

```javascript
useEffect(() => {
  if (replyToMessage && inputRef.current) {
    inputRef.current.focus();
  }
}, [replyToMessage]);
```

Ensure the `inputRef` is attached to the TextInput (add useRef if not already present).

**2. Update ConversationRow for unsent message handling:**

In ConversationRow.js, update the `getPreviewText` function to handle unsent messages:

Check if `lastMessage` has been updated by the unsend cascade. The Cloud Function sets a new lastMessage when unsending. But if the conversation's lastMessage still references an unsent message (race condition), handle gracefully:

Add to the preview text logic:

```javascript
// If lastMessage indicates unsent content
if (lastMessage?.unsent) {
  return isSender ? 'You unsent a message' : 'Message deleted';
}
```

Also handle the case where lastMessage is null (all messages unsent, no fallback):

```javascript
if (!lastMessage || !lastMessage.text) {
  // Check for type-based preview
  if (lastMessage?.type === 'image') return isSender ? 'Sent a photo' : 'Sent a photo';
  if (lastMessage?.type === 'gif') return isSender ? 'Sent a GIF' : 'Sent a GIF';
  return 'No messages yet';
}
```

**ConversationRow should NOT show "Reacted ❤️" as preview text.** The onNewMessage Cloud Function (Plan 02) already handles this by not updating lastMessage for reactions. But add defensive handling: if `lastMessage.type === 'reaction'`, show the previous non-reaction preview or 'Sent a message'.
</action>
<verify>
<automated>npx jest --testPathPattern="**tests**/(components|hooks|services)" --bail 2>&1 | tail -10</automated>
<manual>In a conversation, swipe to reply - verify ReplyPreview appears above input. Check Messages list for correct preview text.</manual>
</verify>
<done>DMInput renders ReplyPreview above input with auto-focus on reply mode. ConversationRow handles unsent and reaction message previews correctly.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Visual verification of all message interactions</name>
  <files>src/screens/ConversationScreen.js</files>
  <action>
Complete message interaction system built: emoji reactions (double-tap heart, long-press picker with 6 emojis), quote replies (swipe-to-reply with preview), and message deletion (unsend within 15 min, delete for me with pixel dialog).

Test on a real device or emulator with two user accounts:

1. Reactions:
   - Open a DM conversation with messages from both users
   - Double-tap a friend's message — heart emoji badge should appear below message
   - Double-tap same message again — heart reaction should toggle OFF (disappear)
   - Long-press a message — dark overlay with emoji row above and action menu below should appear
   - Tap an emoji — reaction badge appears below message, picker closes
   - Tap the reaction badge of your own reaction — reaction toggles off
   - Check Messages list — conversation preview should NOT change when reacting

2. Replies:
   - Long-press a message, tap "Reply" in action menu
   - Verify ReplyPreview bar appears above input showing the quoted message
   - Type a reply and send
   - Verify the sent reply shows with an embedded mini bubble (quoted original) above the reply text
   - Tap the quoted mini bubble — conversation should scroll to the original message and briefly highlight it
   - Swipe right on a message (short swipe ~40px) — reply mode should activate with haptic feedback
   - Test with image and GIF messages — reply preview should show "Photo" or "GIF", not thumbnail

3. Deletion:
   - Long-press your own recent message (less than 15 min old) — verify "Unsend" option appears
   - Tap "Unsend" — message should fade out and show "This message was deleted" for both users
   - Long-press your own message, tap "Delete for me" — pixel-themed dialog should appear
   - Confirm delete — message shows "You deleted this message" in your view only
   - Verify friend still sees the original message (test with second device/account)

4. Edge cases:
   - Try long-pressing a message older than 15 minutes — "Unsend" should NOT appear
   - Tap anywhere outside the reaction picker — it should dismiss

5. Notifications:
   - React to a friend's message — friend should receive push notification with emoji
   - Send a reply — friend should receive standard new message notification
     </action>
     <verify>
     <manual>User verifies all interaction flows work as described above on a real device or emulator</manual>
     </verify>
     <done>User confirms all message interactions (reactions, replies, deletion) work correctly with proper visual styling and edge case handling. Type "approved" or describe issues.</done>
     </task>

</tasks>

<verification>
- Full test suite passes: `npx jest --bail`
- Double-tap adds/removes heart reaction
- Long-press opens picker with 6 emojis and action menu
- Swipe-to-reply with 40px threshold and haptic feedback
- Reply preview above input with cancel
- Reply renders with quoted context inline
- Unsend within 15 min works, shows "This message was deleted"
- Delete for me with pixel dialog, shows "You deleted this message"
- Conversation list preview unchanged by reactions
- Reaction push notifications include emoji
</verification>

<success_criteria>

- All 12 phase requirements (REACT-01..05, REPLY-01..04, DEL-01..03) are implemented
- User confirms visual verification passes on device
- No regressions in existing messaging functionality
- Retro pixel aesthetic maintained in all new UI
  </success_criteria>

<output>
After completion, create `.planning/phases/02-message-interactions/02-06-SUMMARY.md`
</output>
