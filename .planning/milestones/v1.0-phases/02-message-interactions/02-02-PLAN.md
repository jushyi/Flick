---
phase: 02-message-interactions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/index.js
  - firestore.rules
  - functions/__tests__/callable/functions.test.js
  - functions/__tests__/triggers/notifications.test.js
autonomous: true
requirements:
  - REACT-05
  - DEL-01
  - DEL-03

must_haves:
  truths:
    - 'unsendMessage Cloud Function soft-deletes a message within 15-minute window'
    - 'unsendMessage cascades: removes reactions targeting the unsent message and updates replyTo.deleted on replies'
    - 'unsendMessage updates conversation lastMessage if the unsent message was the latest'
    - 'onNewMessage does NOT update lastMessage or unreadCount for reaction messages'
    - 'onNewMessage sends push notification with emoji for reaction messages'
    - 'Firestore rules allow deletedMessages field updates on conversation documents'
  artifacts:
    - path: 'functions/index.js'
      provides: 'unsendMessage callable function, extended onNewMessage for reactions/replies'
      contains: 'unsendMessage'
    - path: 'firestore.rules'
      provides: 'deletedMessages field allowed in conversation update rules'
      contains: 'deletedMessages'
    - path: 'functions/__tests__/callable/functions.test.js'
      provides: 'Tests for unsendMessage callable'
      contains: 'unsendMessage'
  key_links:
    - from: 'functions/index.js (unsendMessage)'
      to: 'conversations/{id}/messages/{id}'
      via: 'admin SDK update for soft-delete fields'
      pattern: 'unsent.*true'
    - from: 'functions/index.js (onNewMessage)'
      to: 'conversations/{id}'
      via: 'conditional lastMessage update based on message type'
      pattern: 'type.*reaction'
---

<objective>
Create unsendMessage Cloud Function, extend onNewMessage for reactions/replies, and update Firestore rules for deletedMessages field.

Purpose: Server-side operations that the client cannot perform directly (message unsend requires admin SDK; onNewMessage needs to differentiate reaction messages from regular messages for notification and preview behavior).
Output: unsendMessage callable function, extended onNewMessage, updated Firestore rules, with tests.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-message-interactions/02-CONTEXT.md
@.planning/phases/02-message-interactions/02-RESEARCH.md
@functions/index.js
@firestore.rules
@functions/__tests__/callable/functions.test.js
@functions/__tests__/triggers/notifications.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unsendMessage callable Cloud Function and update Firestore rules</name>
  <files>functions/index.js, firestore.rules</files>
  <action>
**1. Add unsendMessage callable to functions/index.js:**

Add a new callable function using the v2 `onCall` pattern (already imported):

```
exports.unsendMessage = onCall({ memory: '256MiB', timeoutSeconds: 30 }, async request => { ... });
```

Implementation:

- Extract `conversationId` and `messageId` from `request.data`
- Get `userId` from `request.auth.uid` (throw HttpsError('unauthenticated') if no auth)
- Validate both params (throw HttpsError('invalid-argument') if missing)
- Read the message document from `conversations/{conversationId}/messages/{messageId}`
- Verify message exists (throw HttpsError('not-found'))
- Verify `message.senderId === userId` (throw HttpsError('permission-denied', 'Can only unsend your own messages'))
- Verify within 15-minute window: compare `message.createdAt.toDate()` with `new Date()`, throw HttpsError('failed-precondition', 'Unsend window has expired') if >15 min
- Perform soft-delete: update the message document with `{ unsent: true, unsentAt: admin.firestore.FieldValue.serverTimestamp() }`
- **Cascade 1:** Query all messages in same conversation where `targetMessageId == messageId` (reactions). For each, update `{ unsent: true, unsentAt: admin.firestore.FieldValue.serverTimestamp() }`. Use a batch write.
- **Cascade 2:** Query all messages in same conversation where `replyTo.messageId == messageId` (replies). For each, update `replyTo.deleted` to `true`. Use the same batch.
- **Cascade 3:** Read the conversation document. If `lastMessage.timestamp` matches the unsent message's `createdAt` (or within 1 second tolerance), update `lastMessage` by reading the next most recent non-unsent message and setting it as the new preview. Use: query messages ordered by createdAt desc, limit 2, skip unsent ones. If no other message exists, set `lastMessage` to null.
- Commit the batch
- Return `{ success: true }`

Place this function near the end of the file, before the `onNewMessage` function.

**2. Update Firestore rules for deletedMessages:**

In `firestore.rules`, find the conversation update rule (line ~410-412) and add `'deletedMessages'` to the `hasOnly()` list:

Change:

```
.hasOnly(['deletedAt', 'unreadCount', 'readReceipts']);
```

To:

```
.hasOnly(['deletedAt', 'unreadCount', 'readReceipts', 'deletedMessages']);
```

This allows the client to write `deletedMessages.{userId}` with arrayUnion for the "delete for me" feature.
</action>
<verify>
<automated>cd functions && npx jest **tests**/callable/functions.test.js --bail 2>&1 | tail -5</automated>
<manual>Verify unsendMessage function exists in functions/index.js, Firestore rules include deletedMessages</manual>
</verify>
<done>unsendMessage callable function created with 15-minute window validation, cascade deletion of reactions, cascade replyTo.deleted update, lastMessage fallback. Firestore rules allow deletedMessages.</done>
</task>

<task type="auto">
  <name>Task 2: Extend onNewMessage for reactions/replies and add tests</name>
  <files>functions/index.js, functions/__tests__/callable/functions.test.js, functions/__tests__/triggers/notifications.test.js</files>
  <action>
**1. Extend onNewMessage in functions/index.js:**

Modify the existing `onNewMessage` Cloud Function (line ~2623) to handle reaction and reply message types differently:

After parsing senderId and recipientId (around line 2651), add type-based logic:

```javascript
const messageType = message.type || 'text';

// Determine conversation update behavior based on message type
let lastMessagePreview;
let shouldUpdateLastMessage = true;
let shouldIncrementUnread = true;

if (messageType === 'reaction') {
  // Reactions: send notification but do NOT update conversation preview or unread count
  shouldUpdateLastMessage = false;
  shouldIncrementUnread = false;
} else if (message.replyTo) {
  // Replies: update conversation like normal messages
  lastMessagePreview =
    messageType === 'gif'
      ? 'Sent a GIF'
      : messageType === 'image'
        ? 'Sent a photo'
        : message.text || '';
} else {
  // Standard messages (existing behavior)
  lastMessagePreview =
    messageType === 'gif'
      ? 'Sent a GIF'
      : messageType === 'image'
        ? 'Sent a photo'
        : message.text || '';
}
```

Replace the existing lastMessagePreview and conversation update block with this conditional logic. Only call `convRef.update()` when `shouldUpdateLastMessage` is true.

For the notification section, add reaction-specific notification body:

```javascript
if (messageType === 'reaction' && message.emoji) {
  const emojiMap = {
    heart: '‚ù§Ô∏è',
    laugh: 'üòÇ',
    surprise: 'üòÆ',
    sad: 'üò¢',
    angry: 'üò°',
    thumbs_up: 'üëç',
  };
  const emojiChar = emojiMap[message.emoji] || message.emoji;
  body = `Reacted ${emojiChar} to your message`;
}
```

Also add a guard: if `messageType === 'reaction' && message.emoji === null`, return early (this is a reaction removal sentinel, no notification needed).

**2. Add unsendMessage tests to functions/**tests**/callable/functions.test.js:**

Add a describe block for unsendMessage with these test cases (5):

- Returns success when called with valid params and message within 15-minute window
- Throws unauthenticated when no auth context
- Throws permission-denied when userId doesn't match senderId
- Throws failed-precondition when message is older than 15 minutes
- Sets unsent:true on the message document

Mock the Firestore admin SDK following the existing pattern in the file. Use `jest.fn()` for doc.get, doc.update, collection.where, batch.commit.

**3. Add reaction notification tests to functions/**tests**/triggers/notifications.test.js:**

Add test cases for onNewMessage reaction handling (3):

- Does not update lastMessage or unreadCount for reaction messages
- Sends push notification with emoji character for reaction messages
- Returns early for reaction removal (emoji: null) without sending notification
  </action>
  <verify>
  <automated>cd functions && npx jest --bail --verbose 2>&1 | tail -20</automated>
  </verify>
  <done>onNewMessage correctly differentiates reaction messages (no preview update, emoji notification) from regular messages. unsendMessage callable has 5 tests. Reaction notification has 3 tests. All existing function tests continue to pass.</done>
  </task>

</tasks>

<verification>
- `cd functions && npx jest --bail` passes all tests (existing + new)
- unsendMessage function validates auth, sender match, 15-minute window
- unsendMessage cascades to reactions and replies
- onNewMessage skips lastMessage/unreadCount update for reactions
- onNewMessage sends emoji-formatted notification for reactions
- Firestore rules allow deletedMessages field on conversation documents
</verification>

<success_criteria>

- unsendMessage callable function fully implements soft-delete with cascades
- onNewMessage correctly routes reaction vs regular message handling
- 8+ new Cloud Function tests pass
- Firestore rules updated for deletedMessages
- No regressions in existing Cloud Function tests
  </success_criteria>

<output>
After completion, create `.planning/phases/02-message-interactions/02-02-SUMMARY.md`
</output>
