---
phase: 02-message-interactions
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useConversation.js
  - src/hooks/useMessageActions.js
  - __tests__/hooks/useMessageActions.test.js
autonomous: true
requirements:
  - REACT-01
  - REACT-02
  - REACT-03
  - REPLY-02
  - DEL-02

must_haves:
  truths:
    - 'useConversation builds a reactionMap keyed by targetMessageId from reaction-type messages'
    - 'useConversation filters reaction messages from the display list (not shown in FlatList)'
    - "useConversation filters messages in user's deletedMessages array from the display list"
    - 'useConversation detects unsent messages and renders placeholder data'
    - 'useMessageActions manages action menu state, reply state, and reaction dispatch'
  artifacts:
    - path: 'src/hooks/useConversation.js'
      provides: 'reactionMap, filtered message list excluding reactions and deleted-for-me messages'
      contains: 'reactionMap'
    - path: 'src/hooks/useMessageActions.js'
      provides: 'Hook managing long-press menu state, reply target, reaction sending, unsend calling'
      contains: 'useMessageActions'
    - path: '__tests__/hooks/useMessageActions.test.js'
      provides: 'Tests for useMessageActions hook'
      contains: 'useMessageActions'
  key_links:
    - from: 'src/hooks/useConversation.js'
      to: 'src/services/firebase/messageService.js'
      via: 'imports sendReaction, removeReaction, sendReply'
      pattern: 'import.*sendReaction'
    - from: 'src/hooks/useMessageActions.js'
      to: 'src/services/firebase/messageService.js'
      via: 'imports sendReaction, removeReaction, sendReply, deleteMessageForMe'
      pattern: 'import.*sendReaction'
---

<objective>
Extend useConversation with reaction aggregation and message filtering. Create useMessageActions hook for interaction state management.

Purpose: Bridge the service layer (Plan 01) with the UI layer (Plans 04-06). The hooks compute derived state (reaction maps, filtered lists) and manage interaction state (which message is being replied to, action menu visibility).
Output: Extended useConversation hook, new useMessageActions hook, comprehensive tests.
</objective>

<execution_context>
@C:/Users/maser/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/maser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-message-interactions/02-CONTEXT.md
@.planning/phases/02-message-interactions/02-RESEARCH.md
@.planning/phases/01-message-infrastructure-read-receipts/01-01-SUMMARY.md
@src/hooks/useConversation.js
@src/services/firebase/messageService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend useConversation with reaction aggregation and message filtering</name>
  <files>src/hooks/useConversation.js</files>
  <action>
Extend the existing useConversation hook to support reactions, replies, and deletion:

**1. Import new service functions:**
Add `sendReaction`, `removeReaction`, `sendReply`, `deleteMessageForMe` to the import from messageService.

**2. Add reactionMap computation (useMemo):**
After the existing `messagesWithDividers` or merged message list computation, add:

```javascript
const reactionMap = useMemo(() => {
  const map = new Map(); // targetMessageId -> { [emoji]: [{ senderId, messageId, createdAt }] }
  // Sort by createdAt to process in order (latest reaction per user wins)
  const reactionMsgs = mergedMessages
    .filter(msg => msg.type === 'reaction' && msg.targetMessageId)
    .sort((a, b) => {
      const aTime = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt || 0);
      const bTime = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt || 0);
      return aTime - bTime;
    });

  // Track latest reaction per user per target (for one-reaction-per-user enforcement)
  const latestByUserTarget = new Map(); // `${targetMessageId}_${senderId}` -> { emoji, messageId }

  reactionMsgs.forEach(msg => {
    const key = `${msg.targetMessageId}_${msg.senderId}`;
    latestByUserTarget.set(key, { emoji: msg.emoji, messageId: msg.id, senderId: msg.senderId });
  });

  // Build aggregated map from latest reactions only
  latestByUserTarget.forEach(({ emoji, messageId, senderId }, key) => {
    const targetId = key.split('_')[0]; // Extract targetMessageId from compound key
    if (!emoji) return; // null emoji = removed reaction, skip
    if (!map.has(targetId)) map.set(targetId, {});
    const targetReactions = map.get(targetId);
    if (!targetReactions[emoji]) targetReactions[emoji] = [];
    targetReactions[emoji].push({ senderId, messageId });
  });

  return map;
}, [mergedMessages]);
```

**3. Filter messages for display:**
Modify the existing message list computation to:

- Filter OUT messages where `msg.type === 'reaction'` (reactions are aggregated, not displayed)
- Filter OUT messages where `msg.unsent === true` — replace with placeholder: `{ ...msg, text: null, gifUrl: null, imageUrl: null, _isUnsent: true }`
- Filter OUT messages in `deletedMessages[currentUserId]` — replace with placeholder: `{ ...msg, text: null, gifUrl: null, imageUrl: null, _isDeletedForMe: true }`

Read `deletedMessages` from the conversation document (already subscribed via onSnapshot from Plan 01-01). Add it to the conversationDoc data extraction.

For unsent messages, keep them in the list but with placeholder data so they render as "This message was deleted". For deleted-for-me messages, keep them with placeholder data showing "You deleted this message".

**4. Update return object:**
Add to the hook's return object:

- `reactionMap` — the computed reaction aggregation map
- `sendReaction` — re-export from service (pass conversationId automatically)
- `removeReaction` — re-export from service
- `sendReply` — re-export from service
- `deleteMessageForMe` — re-export from service
- `conversationDoc` — already returned, but ensure deletedMessages is included

Use `useCallback` wrappers for the service functions that auto-bind `conversationId` and `currentUserId`:

```javascript
const handleSendReaction = useCallback(
  (targetMessageId, emoji) => sendReaction(conversationId, currentUserId, targetMessageId, emoji),
  [conversationId, currentUserId]
);
```

  </action>
  <verify>
    <automated>npx jest __tests__/hooks/useConversation.test.js --bail 2>&1 | tail -5</automated>
    <manual>Verify useConversation returns reactionMap and filtered message list</manual>
  </verify>
  <done>useConversation returns reactionMap, filters reaction messages from display, handles unsent/deleted-for-me placeholders, and exposes wrapped service function callbacks</done>
</task>

<task type="auto">
  <name>Task 2: Create useMessageActions hook with tests</name>
  <files>src/hooks/useMessageActions.js, __tests__/hooks/useMessageActions.test.js</files>
  <action>
**1. Create src/hooks/useMessageActions.js:**

A hook managing the state for message interaction UI (action menu, reply mode, reactions):

```javascript
import { useState, useCallback, useRef } from 'react';
import { Keyboard } from 'react-native';
import * as Haptics from 'expo-haptics';

import { getFunctions, httpsCallable } from '@react-native-firebase/functions';

import logger from '../utils/logger';
```

**Hook signature:** `useMessageActions({ conversationId, currentUserId, onSendReaction, onRemoveReaction, onSendReply, onDeleteForMe, flatListRef })`

**State managed:**

- `actionMenuVisible` (boolean) — whether the long-press action menu + reaction picker is open
- `actionMenuMessage` (object|null) — the message that was long-pressed (full message object)
- `actionMenuPosition` (object|null) — `{ x, y, width, height }` of the long-pressed message bubble (for positioning the overlay)
- `replyToMessage` (object|null) — the message being replied to (shows ReplyPreview)

**Exported functions:**

- `openActionMenu(message, layout)` — sets actionMenuVisible=true, actionMenuMessage=message, actionMenuPosition=layout. Trigger medium haptic. Dismiss keyboard.
- `closeActionMenu()` — resets actionMenuVisible, actionMenuMessage, actionMenuPosition to defaults
- `handleReaction(emoji)` — calls onSendReaction(actionMenuMessage.id, emoji), closes menu. If user already reacted with same emoji (check reactionMap from parent), call onRemoveReaction instead (toggle). Note: the reactionMap is NOT in this hook — it's passed from useConversation. Accept `reactionMap` as a param or accept a `getUserReaction(messageId)` helper.
- `handleDoubleTapHeart(messageId)` — shortcut: calls onSendReaction(messageId, 'heart'). Trigger light haptic. If user already reacted with heart, call onRemoveReaction (toggle).
- `startReply(message)` — sets replyToMessage=message, closes action menu if open, focuses keyboard (caller handles actual focus via ref)
- `cancelReply()` — sets replyToMessage=null
- `handleUnsend(messageId)` — calls the unsendMessage Cloud Function via `httpsCallable(getFunctions(), 'unsendMessage')({ conversationId, messageId })`. Close the action menu. Handle errors gracefully (log, don't crash).
- `handleDeleteForMe(messageId)` — calls onDeleteForMe(messageId), closes action menu

**Key behavior:**

- `openActionMenu` triggers `Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium)`
- `handleDoubleTapHeart` triggers `Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light)`
- All functions that close menu also reset position
- Edge case: if actionMenuMessage gets unsent while menu is open, the menu should be closeable without error (check for message existence before acting)

**2. Create **tests**/hooks/useMessageActions.test.js:**

Test the hook using `renderHook` from `@testing-library/react-hooks` (or `@testing-library/react-native`). Mock expo-haptics, Firebase functions.

Test cases (8):

- openActionMenu sets visible=true and message, triggers haptic
- closeActionMenu resets all state
- handleReaction calls onSendReaction with correct params and closes menu
- handleReaction toggles to removeReaction when user already reacted with same emoji
- handleDoubleTapHeart calls onSendReaction with 'heart' emoji
- startReply sets replyToMessage and closes action menu
- cancelReply clears replyToMessage
- handleUnsend calls Cloud Function httpsCallable with correct params

Follow the existing hook test pattern from `__tests__/hooks/useConversation.test.js`: mock functions at module scope, use `jest.mock()` with factory functions.
</action>
<verify>
<automated>npx jest **tests**/hooks/useMessageActions.test.js --bail --verbose 2>&1 | tail -20</automated>
</verify>
<done>useMessageActions hook created with all state management for action menu, reply mode, and reaction dispatch. 8 tests pass covering all interaction paths.</done>
</task>

</tasks>

<verification>
- `npx jest __tests__/hooks/ --bail` passes all hook tests (existing + new)
- useConversation.reactionMap correctly aggregates reaction messages by targetMessageId
- useConversation message list excludes reaction-type messages from display
- useConversation handles unsent and deleted-for-me message placeholders
- useMessageActions manages action menu, reply, and reaction state correctly
</verification>

<success_criteria>

- useConversation returns reactionMap with correct aggregation logic
- Message list filtered: no reaction messages visible, unsent/deleted show placeholders
- useMessageActions provides complete state management for all Phase 2 interactions
- 8+ new tests pass for useMessageActions
- Existing useConversation tests continue to pass
  </success_criteria>

<output>
After completion, create `.planning/phases/02-message-interactions/02-03-SUMMARY.md`
</output>
